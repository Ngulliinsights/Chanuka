/**
 * Comment Domain Entity - Re-exports from Canonical Source
 * 
 * This file re-exports from the canonical Comment type location.
 * Domain logic (Comment class) is preserved here as it's server-specific.
 * 
 * CANONICAL SOURCE: shared/types/domains/legislative/comment.ts
 */

// ============================================================================
// Re-exports from Canonical Source
// ============================================================================

export type {
  Comment as CommentEntity,
  CreateCommentPayload as CreateCommentInput,
  UpdateCommentPayload as UpdateCommentInput,
} from '@shared/types/domains/legislative/comment';

// ============================================================================
// Domain Logic (Server-Specific)
// ============================================================================

import type { Comment as CommentEntity } from '@shared/types/domains/legislative/comment';

/**
 * Comment Domain Logic
 * Server-side domain model with business logic
 */
export class Comment {
  private constructor(private readonly data: CommentEntity) {}

  static create(input: { billId: string; userId: string; content: string; parentCommentId?: string | null }): Comment {
    const entity: CommentEntity = {
      id: '', // Generated by infrastructure
      billId: input.billId,
      userId: input.userId,
      parentCommentId: input.parentCommentId || null,
      content: input.content,
      contentHtml: null,
      upvotes: 0,
      downvotes: 0,
      replyCount: 0,
      moderationStatus: 'pending',
      moderationReason: null,
      moderatedBy: null,
      moderatedAt: null,
      isEdited: false,
      isPinned: false,
      isExpertComment: false,
      createdAt: new Date(),
      updatedAt: new Date(),
      deletedAt: null,
    };

    return new Comment(entity);
  }

  static fromPersistence(data: CommentEntity): Comment {
    return new Comment(data);
  }

  // Domain methods
  upvote(): void {
    (this.data as any).upvotes++;
    (this.data as any).updatedAt = new Date();
  }

  downvote(): void {
    (this.data as any).downvotes++;
    (this.data as any).updatedAt = new Date();
  }

  removeUpvote(): void {
    if (this.data.upvotes > 0) {
      (this.data as any).upvotes--;
      (this.data as any).updatedAt = new Date();
    }
  }

  removeDownvote(): void {
    if (this.data.downvotes > 0) {
      (this.data as any).downvotes--;
      (this.data as any).updatedAt = new Date();
    }
  }

  approve(moderatorId: string): void {
    (this.data as any).moderationStatus = 'approved';
    (this.data as any).moderatedBy = moderatorId;
    (this.data as any).moderatedAt = new Date();
    (this.data as any).updatedAt = new Date();
  }

  reject(moderatorId: string, reason: string): void {
    (this.data as any).moderationStatus = 'rejected';
    (this.data as any).moderationReason = reason;
    (this.data as any).moderatedBy = moderatorId;
    (this.data as any).moderatedAt = new Date();
    (this.data as any).updatedAt = new Date();
  }

  flag(reason: string): void {
    (this.data as any).moderationStatus = 'flagged';
    (this.data as any).moderationReason = reason;
    (this.data as any).updatedAt = new Date();
  }

  edit(content: string): void {
    (this.data as any).content = content;
    (this.data as any).isEdited = true;
    (this.data as any).updatedAt = new Date();
  }

  pin(): void {
    (this.data as any).isPinned = true;
    (this.data as any).updatedAt = new Date();
  }

  unpin(): void {
    (this.data as any).isPinned = false;
    (this.data as any).updatedAt = new Date();
  }

  incrementReplyCount(): void {
    (this.data as any).replyCount = (this.data.replyCount || 0) + 1;
    (this.data as any).updatedAt = new Date();
  }

  decrementReplyCount(): void {
    if ((this.data.replyCount || 0) > 0) {
      (this.data as any).replyCount = (this.data.replyCount || 0) - 1;
      (this.data as any).updatedAt = new Date();
    }
  }

  softDelete(): void {
    (this.data as any).deletedAt = new Date();
    (this.data as any).updatedAt = new Date();
  }

  // Getters
  get id(): string {
    return this.data.id as string;
  }

  get netVotes(): number {
    return this.data.upvotes - this.data.downvotes;
  }

  get isDeleted(): boolean {
    return this.data.deletedAt !== null && this.data.deletedAt !== undefined;
  }

  get isApproved(): boolean {
    return this.data.moderationStatus === 'approved';
  }

  get isPending(): boolean {
    return this.data.moderationStatus === 'pending';
  }

  get isFlagged(): boolean {
    return this.data.moderationStatus === 'flagged';
  }

  get isReply(): boolean {
    return this.data.parentCommentId !== null && this.data.parentCommentId !== undefined;
  }

  toJSON(): CommentEntity {
    return { ...this.data };
  }
}