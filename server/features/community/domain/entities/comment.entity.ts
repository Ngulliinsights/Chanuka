/**
 * Comment Domain Entity
 * 
 * Represents a citizen's comment on a bill with voting and moderation capabilities.
 * Core domain entity for community engagement.
 */

export interface CommentEntity {
  id: string;
  billId: string;
  userId: string;
  parentCommentId: string | null;
  
  // Content
  content: string;
  contentHtml: string | null;
  
  // Engagement metrics (denormalized for performance)
  upvotes: number;
  downvotes: number;
  replyCount: number;
  
  // Moderation
  moderationStatus: 'pending' | 'approved' | 'rejected' | 'flagged';
  moderationReason: string | null;
  moderatedBy: string | null;
  moderatedAt: Date | null;
  
  // Metadata
  isEdited: boolean;
  isPinned: boolean;
  isExpertComment: boolean;
  
  // Audit
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

export interface CreateCommentInput {
  billId: string;
  userId: string;
  content: string;
  parentCommentId?: string | null;
}

export interface UpdateCommentInput {
  content?: string;
  moderationStatus?: 'pending' | 'approved' | 'rejected' | 'flagged';
  moderationReason?: string | null;
  isPinned?: boolean;
}

/**
 * Comment Domain Logic
 */
export class Comment {
  private constructor(private readonly data: CommentEntity) {}

  static create(input: CreateCommentInput): Comment {
    const entity: CommentEntity = {
      id: '', // Generated by infrastructure
      billId: input.billId,
      userId: input.userId,
      parentCommentId: input.parentCommentId || null,
      content: input.content,
      contentHtml: null,
      upvotes: 0,
      downvotes: 0,
      replyCount: 0,
      moderationStatus: 'pending',
      moderationReason: null,
      moderatedBy: null,
      moderatedAt: null,
      isEdited: false,
      isPinned: false,
      isExpertComment: false,
      createdAt: new Date(),
      updatedAt: new Date(),
      deletedAt: null,
    };

    return new Comment(entity);
  }

  static fromPersistence(data: CommentEntity): Comment {
    return new Comment(data);
  }

  // Domain methods
  upvote(): void {
    this.data.upvotes++;
    this.data.updatedAt = new Date();
  }

  downvote(): void {
    this.data.downvotes++;
    this.data.updatedAt = new Date();
  }

  removeUpvote(): void {
    if (this.data.upvotes > 0) {
      this.data.upvotes--;
      this.data.updatedAt = new Date();
    }
  }

  removeDownvote(): void {
    if (this.data.downvotes > 0) {
      this.data.downvotes--;
      this.data.updatedAt = new Date();
    }
  }

  approve(moderatorId: string): void {
    this.data.moderationStatus = 'approved';
    this.data.moderatedBy = moderatorId;
    this.data.moderatedAt = new Date();
    this.data.updatedAt = new Date();
  }

  reject(moderatorId: string, reason: string): void {
    this.data.moderationStatus = 'rejected';
    this.data.moderationReason = reason;
    this.data.moderatedBy = moderatorId;
    this.data.moderatedAt = new Date();
    this.data.updatedAt = new Date();
  }

  flag(reason: string): void {
    this.data.moderationStatus = 'flagged';
    this.data.moderationReason = reason;
    this.data.updatedAt = new Date();
  }

  edit(content: string): void {
    this.data.content = content;
    this.data.isEdited = true;
    this.data.updatedAt = new Date();
  }

  pin(): void {
    this.data.isPinned = true;
    this.data.updatedAt = new Date();
  }

  unpin(): void {
    this.data.isPinned = false;
    this.data.updatedAt = new Date();
  }

  incrementReplyCount(): void {
    this.data.replyCount++;
    this.data.updatedAt = new Date();
  }

  decrementReplyCount(): void {
    if (this.data.replyCount > 0) {
      this.data.replyCount--;
      this.data.updatedAt = new Date();
    }
  }

  softDelete(): void {
    this.data.deletedAt = new Date();
    this.data.updatedAt = new Date();
  }

  // Getters
  get id(): string {
    return this.data.id;
  }

  get netVotes(): number {
    return this.data.upvotes - this.data.downvotes;
  }

  get isDeleted(): boolean {
    return this.data.deletedAt !== null;
  }

  get isApproved(): boolean {
    return this.data.moderationStatus === 'approved';
  }

  get isPending(): boolean {
    return this.data.moderationStatus === 'pending';
  }

  get isFlagged(): boolean {
    return this.data.moderationStatus === 'flagged';
  }

  get isReply(): boolean {
    return this.data.parentCommentId !== null;
  }

  toJSON(): CommentEntity {
    return { ...this.data };
  }
}
