import { database as db } from '@shared/database/connection';
import { user_verification } from '@shared/schema';
import { eq, and, sql, inArray } from 'drizzle-orm';
import { VerificationRepository } from '../../domain/repositories/verification-repository';
import { CitizenVerification, VerificationType } from '../../domain/entities/citizen-verification';

// Type mapping helpers to bridge domain and database schemas
type DbVerificationStatus = 'verified' | 'pending' | 'rejected' | 'disputed';
type DbVerificationType = 'constitutional' | 'stakeholder' | 'impact' | 'accuracy' | 'community';

export class VerificationRepositoryImpl implements VerificationRepository {
  
  // Helper method to map domain verification type to database enum
  private mapVerificationTypeToDb(type: VerificationType): DbVerificationType {
    const typeMap: Record<string, DbVerificationType> = {
      'fact_check': 'accuracy',
      'impact_assessment': 'impact',
      'source_validation': 'accuracy',
      'claim_verification': 'accuracy',
      'constitutional': 'constitutional',
      'stakeholder': 'stakeholder',
      'impact': 'impact',
      'accuracy': 'accuracy',
      'community': 'community'
    };
    return typeMap[type] || 'community';
  }

  // Helper method to map domain verification status to database enum
  private mapVerificationStatusToDb(status: string): DbVerificationStatus {
    const statusMap: Record<string, DbVerificationStatus> = {
      'needs_review': 'pending',
      'verified': 'verified',
      'pending': 'pending',
      'rejected': 'rejected',
      'disputed': 'disputed'
    };
    return statusMap[status] || 'pending';
  }

  // Basic CRUD operations
  async findById(id: string): Promise<CitizenVerification | null> {
    const result = await db
      .select()
      .from(verifications)
      .where(eq(verifications.id, id))
      .limit(1);

    return result[0] ? this.mapToDomain(result[0]) : null;
  }

  async findByBillId(bill_id: number): Promise<CitizenVerification[]> { const results = await db
      .select()
      .from(verifications)
      .where(eq(verifications.bill_id, bill_id));

    return results.map(result => this.mapToDomain(result));
   }

  async findByCitizenId(citizenId: string): Promise<CitizenVerification[]> {
    const results = await db
      .select()
      .from(verifications)
      .where(eq(verifications.user_id, citizenId));

    return results.map(result => this.mapToDomain(result));
  }

  async save(verification: CitizenVerification): Promise<void> { const verification_data = verification.toJSON();
    
    // Don't include 'id' if it should be auto-generated by the database
    // Only include it if your schema expects manual ID assignment
    await db.insert(verifications).values({
      // Remove 'id' field to let database auto-generate it
      bill_id: verification_data.bill_id,
      user_id: verification_data.citizenId,
      user_role: 'citizen', // Assuming this is required by your schema
      verification_type: this.mapVerificationTypeToDb(verification_data.verification_type),
      verification_status: this.mapVerificationStatusToDb(verification_data.verification_status),
      confidence: verification_data.confidence.toString(),
      evidence: verification_data.evidence,
      expertise: verification_data.expertise,
      reasoning: verification_data.reasoning,
      endorsements: verification_data.endorsements,
      disputes: verification_data.disputes,
      created_at: verification_data.created_at,
      updated_at: verification_data.updated_at
      });
  }

  async update(verification: CitizenVerification): Promise<void> {
    const verification_data = verification.toJSON();
    
    await db
      .update(verifications)
      .set({
        verification_status: this.mapVerificationStatusToDb(verification_data.verification_status),
        confidence: verification_data.confidence.toString(),
        evidence: verification_data.evidence,
        expertise: verification_data.expertise,
        reasoning: verification_data.reasoning,
        endorsements: verification_data.endorsements,
        disputes: verification_data.disputes,
        updated_at: verification_data.updated_at
      })
      .where(eq(verifications.id, verification_data.id));
  }

  async delete(id: string): Promise<void> {
    await db.delete(verifications).where(eq(verifications.id, id));
  }

  // Query operations with proper type mapping
  async findByType(bill_id: number, type: VerificationType): Promise<CitizenVerification[]> { const dbType = this.mapVerificationTypeToDb(type);
    
    const results = await db
      .select()
      .from(verifications)
      .where(and(
        eq(verifications.bill_id, bill_id),
        eq(verifications.verification_type, dbType)
      ));

    return results.map(result => this.mapToDomain(result));
   }

  async findByStatus(bill_id: number, status: string): Promise<CitizenVerification[]> { const dbStatus = this.mapVerificationStatusToDb(status);
    
    const results = await db
      .select()
      .from(verifications)
      .where(and(
        eq(verifications.bill_id, bill_id),
        eq(verifications.verification_status, dbStatus)
      ));

    return results.map(result => this.mapToDomain(result));
   }

  async findByConfidenceRange(bill_id: number, min: number, max: number): Promise<CitizenVerification[]> { const results = await db
      .select()
      .from(verifications)
      .where(and(
        eq(verifications.bill_id, bill_id),
        sql`${verifications.confidence }::numeric >= ${min}`,
        sql`${verifications.confidence}::numeric <= ${max}`
      ));

    return results.map(result => this.mapToDomain(result));
  }

  async findRecentVerifications(limit: number): Promise<CitizenVerification[]> {
    const results = await db
      .select()
      .from(verifications)
      .orderBy(sql`${verifications.created_at} DESC`)
      .limit(limit);

    return results.map(result => this.mapToDomain(result));
  }

  // Aggregation operations
  async countByBillId(bill_id: number): Promise<number> {
    const result = await db
      .select({ value: sql<number>`count(*)::int` })
      .from(verifications)
      .where(eq(verifications.bill_id, bill_id));

    return Number(result[0]?.value ?? 0);
  }

  async countByStatus(bill_id: number): Promise<Record<string, number>> {
    const results = await db
      .select({
        status: verifications.verification_status,
        count: sql<number>`count(*)::int`
      })
      .from(verifications)
      .where(eq(verifications.bill_id, bill_id))
      .groupBy(verifications.verification_status);

    const statusCounts: Record<string, number> = {};
    results.forEach(result => {
      statusCounts[result.status] = Number(result.count);
    });

    return statusCounts;
  }

  async getAverageConfidence(bill_id: number): Promise<number> {
    const result = await db
      .select({ value: sql<number>`avg(${verifications.confidence}::numeric)` })
      .from(verifications)
      .where(eq(verifications.bill_id, bill_id));

    return Number(result[0]?.value ?? 0);
  }

  async getExpertiseDistribution(bill_id: number): Promise<Record<string, number>> {
    const results = await db
      .select({
        domain: sql<string>`${verifications.expertise}->>'domain'`,
        count: sql<number>`count(*)::int`
      })
      .from(verifications)
      .where(eq(verifications.bill_id, bill_id))
      .groupBy(sql`${verifications.expertise}->>'domain'`);

    const distribution: Record<string, number> = {};
    results.forEach(result => {
      if (result.domain) {
        distribution[result.domain] = Number(result.count);
      }
    });

    return distribution;
  }

  // Community operations
  async findEndorsements(verificationId: string): Promise<string[]> {
    // This would require a separate endorsements table in production
    return [];
  }

  async findDisputes(verificationId: string): Promise<string[]> {
    // This would require a separate disputes table in production
    return [];
  }

  async addEndorsement(verificationId: string, citizenId: string): Promise<void> {
    await db
      .update(verifications)
      .set({
        endorsements: sql`${verifications.endorsements} + 1`,
        updated_at: new Date()
      })
      .where(eq(verifications.id, verificationId));
  }

  async addDispute(verificationId: string, citizenId: string, reason: string): Promise<void> {
    await db
      .update(verifications)
      .set({
        disputes: sql`${verifications.disputes} + 1`,
        updated_at: new Date()
      })
      .where(eq(verifications.id, verificationId));
  }

  async removeEndorsement(verificationId: string, citizenId: string): Promise<void> {
    await db
      .update(verifications)
      .set({
        endorsements: sql`GREATEST(${verifications.endorsements} - 1, 0)`,
        updated_at: new Date()
      })
      .where(eq(verifications.id, verificationId));
  }

  async removeDispute(verificationId: string, citizenId: string): Promise<void> {
    await db
      .update(verifications)
      .set({
        disputes: sql`GREATEST(${verifications.disputes} - 1, 0)`,
        updated_at: new Date()
      })
      .where(eq(verifications.id, verificationId));
  }

  // Fact-checking operations
  async findRelevantVerifications(bill_id: number, claim: string): Promise<CitizenVerification[]> {
    const searchTerm = `%${claim.toLowerCase()}%`;
    const results = await db
      .select()
      .from(verifications)
      .where(and(
        eq(verifications.bill_id, bill_id),
        sql`LOWER(${verifications.reasoning}) LIKE ${searchTerm}`
      ));

    return results.map(result => this.mapToDomain(result));
  }

  async getConsensusLevel(verificationId: string): Promise<number> {
    const result = await db
      .select({
        endorsements: verifications.endorsements,
        disputes: verifications.disputes
      })
      .from(verifications)
      .where(eq(verifications.id, verificationId))
      .limit(1);

    if (!result[0]) return 50;

    const total = result[0].endorsements + result[0].disputes;
    if (total === 0) return 50;

    return Math.round((result[0].endorsements / total) * 100);
  }

  async getCommunityConsensus(verificationId: string): Promise<number> {
    return this.getConsensusLevel(verificationId);
  }

  // Bulk operations with proper type safety
  async updateStatusBulk(verificationIds: string[], status: string): Promise<void> {
    const dbStatus = this.mapVerificationStatusToDb(status);
    
    await db
      .update(verifications)
      .set({
        verification_status: dbStatus,
        updated_at: new Date()
      })
      .where(inArray(verifications.id, verificationIds));
  }

  async deleteByBillId(bill_id: number): Promise<void> { await db.delete(verifications).where(eq(verifications.bill_id, bill_id));
   }

  // Statistics
  async getVerificationStats(bill_id: number): Promise<{
    total: number;
    verified: number;
    disputed: number;
    pending: number;
    needsReview: number;
    averageConfidence: number;
    reliabilityScore: number;
  }> { const [totalResult, statusCounts, avgConfidenceResult] = await Promise.all([
      this.countByBillId(bill_id),
      this.countByStatus(bill_id),
      this.getAverageConfidence(bill_id)
    ]);

    const stats = {
      total: totalResult,
      verified: statusCounts.verified || 0,
      disputed: statusCounts.disputed || 0,
      pending: statusCounts.pending || 0,
      needsReview: statusCounts.needs_review || 0,
      averageConfidence: avgConfidenceResult,
      reliabilityScore: Math.round((avgConfidenceResult + (statusCounts.verified / Math.max(totalResult, 1)) * 100) / 2)
     };

    return stats;
  }

  // Helper method to map database result to domain entity
  private mapToDomain(result: any): CitizenVerification {
    const evidence = Array.isArray(result.evidence) ? result.evidence.map((e: any) => ({
      type: e.type,
      source: e.source,
      url: e.url,
      credibility: e.credibility,
      relevance: e.relevance,
      description: e.description,
      datePublished: e.datePublished
    })) : [];

    const expertise = {
      domain: result.expertise?.domain || '',
      level: result.expertise?.level || 0,
      credentials: result.expertise?.credentials || [],
      verifiedCredentials: result.expertise?.verifiedCredentials || false,
      reputation_score: result.expertise?.reputation_score || 0
    };

    return CitizenVerification.create({ id: result.id,
      bill_id: result.bill_id,
      citizenId: result.user_id,
      verification_type: result.verification_type as VerificationType,
      verification_status: result.verification_status as any,
      confidence: Number(result.confidence),
      evidence: evidence as any,
      expertise: expertise as any,
      reasoning: result.reasoning,
      endorsements: result.endorsements || 0,
      disputes: result.disputes || 0,
      created_at: result.created_at,
      updated_at: result.updated_at
     });
  }
}
