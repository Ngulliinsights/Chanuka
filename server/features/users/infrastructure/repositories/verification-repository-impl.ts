import { database as db } from '@shared/database/connection';
import { verifications } from '@shared/schema/schema';
import { eq, and, sql, inArray } from 'drizzle-orm';
import { VerificationRepository } from '../../domain/repositories/verification-repository';
import { CitizenVerification, VerificationType } from '../../domain/entities/citizen-verification';

// Type mapping helpers to bridge domain and database schemas
type DbVerificationStatus = 'verified' | 'pending' | 'rejected' | 'disputed';
type DbVerificationType = 'constitutional' | 'stakeholder' | 'impact' | 'accuracy' | 'community';

export class VerificationRepositoryImpl implements VerificationRepository {
  
  // Helper method to map domain verification type to database enum
  private mapVerificationTypeToDb(type: VerificationType): DbVerificationType {
    const typeMap: Record<string, DbVerificationType> = {
      'fact_check': 'accuracy',
      'impact_assessment': 'impact',
      'source_validation': 'accuracy',
      'claim_verification': 'accuracy',
      'constitutional': 'constitutional',
      'stakeholder': 'stakeholder',
      'impact': 'impact',
      'accuracy': 'accuracy',
      'community': 'community'
    };
    return typeMap[type] || 'community';
  }

  // Helper method to map domain verification status to database enum
  private mapVerificationStatusToDb(status: string): DbVerificationStatus {
    const statusMap: Record<string, DbVerificationStatus> = {
      'needs_review': 'pending',
      'verified': 'verified',
      'pending': 'pending',
      'rejected': 'rejected',
      'disputed': 'disputed'
    };
    return statusMap[status] || 'pending';
  }

  // Basic CRUD operations
  async findById(id: string): Promise<CitizenVerification | null> {
    const result = await db
      .select()
      .from(verifications)
      .where(eq(verifications.id, id))
      .limit(1);

    return result[0] ? this.mapToDomain(result[0]) : null;
  }

  async findByBillId(billId: number): Promise<CitizenVerification[]> {
    const results = await db
      .select()
      .from(verifications)
      .where(eq(verifications.billId, billId));

    return results.map(result => this.mapToDomain(result));
  }

  async findByCitizenId(citizenId: string): Promise<CitizenVerification[]> {
    const results = await db
      .select()
      .from(verifications)
      .where(eq(verifications.userId, citizenId));

    return results.map(result => this.mapToDomain(result));
  }

  async save(verification: CitizenVerification): Promise<void> {
    const verificationData = verification.toJSON();
    
    // Don't include 'id' if it should be auto-generated by the database
    // Only include it if your schema expects manual ID assignment
    await db.insert(verifications).values({
      // Remove 'id' field to let database auto-generate it
      billId: verificationData.billId,
      userId: verificationData.citizenId,
      userRole: 'citizen', // Assuming this is required by your schema
      verificationType: this.mapVerificationTypeToDb(verificationData.verificationType),
      verificationStatus: this.mapVerificationStatusToDb(verificationData.verificationStatus),
      confidence: verificationData.confidence.toString(),
      evidence: verificationData.evidence,
      expertise: verificationData.expertise,
      reasoning: verificationData.reasoning,
      endorsements: verificationData.endorsements,
      disputes: verificationData.disputes,
      createdAt: verificationData.createdAt,
      updatedAt: verificationData.updatedAt
    });
  }

  async update(verification: CitizenVerification): Promise<void> {
    const verificationData = verification.toJSON();
    
    await db
      .update(verifications)
      .set({
        verificationStatus: this.mapVerificationStatusToDb(verificationData.verificationStatus),
        confidence: verificationData.confidence.toString(),
        evidence: verificationData.evidence,
        expertise: verificationData.expertise,
        reasoning: verificationData.reasoning,
        endorsements: verificationData.endorsements,
        disputes: verificationData.disputes,
        updatedAt: verificationData.updatedAt
      })
      .where(eq(verifications.id, verificationData.id));
  }

  async delete(id: string): Promise<void> {
    await db.delete(verifications).where(eq(verifications.id, id));
  }

  // Query operations with proper type mapping
  async findByType(billId: number, type: VerificationType): Promise<CitizenVerification[]> {
    const dbType = this.mapVerificationTypeToDb(type);
    
    const results = await db
      .select()
      .from(verifications)
      .where(and(
        eq(verifications.billId, billId),
        eq(verifications.verificationType, dbType)
      ));

    return results.map(result => this.mapToDomain(result));
  }

  async findByStatus(billId: number, status: string): Promise<CitizenVerification[]> {
    const dbStatus = this.mapVerificationStatusToDb(status);
    
    const results = await db
      .select()
      .from(verifications)
      .where(and(
        eq(verifications.billId, billId),
        eq(verifications.verificationStatus, dbStatus)
      ));

    return results.map(result => this.mapToDomain(result));
  }

  async findByConfidenceRange(billId: number, min: number, max: number): Promise<CitizenVerification[]> {
    const results = await db
      .select()
      .from(verifications)
      .where(and(
        eq(verifications.billId, billId),
        sql`${verifications.confidence}::numeric >= ${min}`,
        sql`${verifications.confidence}::numeric <= ${max}`
      ));

    return results.map(result => this.mapToDomain(result));
  }

  async findRecentVerifications(limit: number): Promise<CitizenVerification[]> {
    const results = await db
      .select()
      .from(verifications)
      .orderBy(sql`${verifications.createdAt} DESC`)
      .limit(limit);

    return results.map(result => this.mapToDomain(result));
  }

  // Aggregation operations
  async countByBillId(billId: number): Promise<number> {
    const result = await db
      .select({ value: sql<number>`count(*)::int` })
      .from(verifications)
      .where(eq(verifications.billId, billId));

    return Number(result[0]?.value ?? 0);
  }

  async countByStatus(billId: number): Promise<Record<string, number>> {
    const results = await db
      .select({
        status: verifications.verificationStatus,
        count: sql<number>`count(*)::int`
      })
      .from(verifications)
      .where(eq(verifications.billId, billId))
      .groupBy(verifications.verificationStatus);

    const statusCounts: Record<string, number> = {};
    results.forEach(result => {
      statusCounts[result.status] = Number(result.count);
    });

    return statusCounts;
  }

  async getAverageConfidence(billId: number): Promise<number> {
    const result = await db
      .select({ value: sql<number>`avg(${verifications.confidence}::numeric)` })
      .from(verifications)
      .where(eq(verifications.billId, billId));

    return Number(result[0]?.value ?? 0);
  }

  async getExpertiseDistribution(billId: number): Promise<Record<string, number>> {
    const results = await db
      .select({
        domain: sql<string>`${verifications.expertise}->>'domain'`,
        count: sql<number>`count(*)::int`
      })
      .from(verifications)
      .where(eq(verifications.billId, billId))
      .groupBy(sql`${verifications.expertise}->>'domain'`);

    const distribution: Record<string, number> = {};
    results.forEach(result => {
      if (result.domain) {
        distribution[result.domain] = Number(result.count);
      }
    });

    return distribution;
  }

  // Community operations
  async findEndorsements(verificationId: string): Promise<string[]> {
    // This would require a separate endorsements table in production
    return [];
  }

  async findDisputes(verificationId: string): Promise<string[]> {
    // This would require a separate disputes table in production
    return [];
  }

  async addEndorsement(verificationId: string, citizenId: string): Promise<void> {
    await db
      .update(verifications)
      .set({
        endorsements: sql`${verifications.endorsements} + 1`,
        updatedAt: new Date()
      })
      .where(eq(verifications.id, verificationId));
  }

  async addDispute(verificationId: string, citizenId: string, reason: string): Promise<void> {
    await db
      .update(verifications)
      .set({
        disputes: sql`${verifications.disputes} + 1`,
        updatedAt: new Date()
      })
      .where(eq(verifications.id, verificationId));
  }

  async removeEndorsement(verificationId: string, citizenId: string): Promise<void> {
    await db
      .update(verifications)
      .set({
        endorsements: sql`GREATEST(${verifications.endorsements} - 1, 0)`,
        updatedAt: new Date()
      })
      .where(eq(verifications.id, verificationId));
  }

  async removeDispute(verificationId: string, citizenId: string): Promise<void> {
    await db
      .update(verifications)
      .set({
        disputes: sql`GREATEST(${verifications.disputes} - 1, 0)`,
        updatedAt: new Date()
      })
      .where(eq(verifications.id, verificationId));
  }

  // Fact-checking operations
  async findRelevantVerifications(billId: number, claim: string): Promise<CitizenVerification[]> {
    const searchTerm = `%${claim.toLowerCase()}%`;
    const results = await db
      .select()
      .from(verifications)
      .where(and(
        eq(verifications.billId, billId),
        sql`LOWER(${verifications.reasoning}) LIKE ${searchTerm}`
      ));

    return results.map(result => this.mapToDomain(result));
  }

  async getConsensusLevel(verificationId: string): Promise<number> {
    const result = await db
      .select({
        endorsements: verifications.endorsements,
        disputes: verifications.disputes
      })
      .from(verifications)
      .where(eq(verifications.id, verificationId))
      .limit(1);

    if (!result[0]) return 50;

    const total = result[0].endorsements + result[0].disputes;
    if (total === 0) return 50;

    return Math.round((result[0].endorsements / total) * 100);
  }

  async getCommunityConsensus(verificationId: string): Promise<number> {
    return this.getConsensusLevel(verificationId);
  }

  // Bulk operations with proper type safety
  async updateStatusBulk(verificationIds: string[], status: string): Promise<void> {
    const dbStatus = this.mapVerificationStatusToDb(status);
    
    await db
      .update(verifications)
      .set({
        verificationStatus: dbStatus,
        updatedAt: new Date()
      })
      .where(inArray(verifications.id, verificationIds));
  }

  async deleteByBillId(billId: number): Promise<void> {
    await db.delete(verifications).where(eq(verifications.billId, billId));
  }

  // Statistics
  async getVerificationStats(billId: number): Promise<{
    total: number;
    verified: number;
    disputed: number;
    pending: number;
    needsReview: number;
    averageConfidence: number;
    reliabilityScore: number;
  }> {
    const [totalResult, statusCounts, avgConfidenceResult] = await Promise.all([
      this.countByBillId(billId),
      this.countByStatus(billId),
      this.getAverageConfidence(billId)
    ]);

    const stats = {
      total: totalResult,
      verified: statusCounts.verified || 0,
      disputed: statusCounts.disputed || 0,
      pending: statusCounts.pending || 0,
      needsReview: statusCounts.needs_review || 0,
      averageConfidence: avgConfidenceResult,
      reliabilityScore: Math.round((avgConfidenceResult + (statusCounts.verified / Math.max(totalResult, 1)) * 100) / 2)
    };

    return stats;
  }

  // Helper method to map database result to domain entity
  private mapToDomain(result: any): CitizenVerification {
    const evidence = Array.isArray(result.evidence) ? result.evidence.map((e: any) => ({
      type: e.type,
      source: e.source,
      url: e.url,
      credibility: e.credibility,
      relevance: e.relevance,
      description: e.description,
      datePublished: e.datePublished
    })) : [];

    const expertise = {
      domain: result.expertise?.domain || '',
      level: result.expertise?.level || 0,
      credentials: result.expertise?.credentials || [],
      verifiedCredentials: result.expertise?.verifiedCredentials || false,
      reputationScore: result.expertise?.reputationScore || 0
    };

    return CitizenVerification.create({
      id: result.id,
      billId: result.billId,
      citizenId: result.userId,
      verificationType: result.verificationType as VerificationType,
      verificationStatus: result.verificationStatus as any,
      confidence: Number(result.confidence),
      evidence: evidence as any,
      expertise: expertise as any,
      reasoning: result.reasoning,
      endorsements: result.endorsements || 0,
      disputes: result.disputes || 0,
      createdAt: result.createdAt,
      updatedAt: result.updatedAt
    });
  }
}