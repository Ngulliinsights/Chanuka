# Chanuka Platform UI Design Specification
## Document Control
**Version:** 1.0  
**Date:** November 8, 2025  
**Related Documents:** Requirements Specification v1.0  
**Optimization:** Gen-AI Coding Agent Compatible

## Executive Summary

### Problem Statement

Citizens attempting to engage with legislative transparency face three critical challenges that current implementations fail to address adequately:

1. **Information Overload Without Context**: Legislative information exists but remains inaccessible due to legal complexity, poor information architecture, and lack of contextual guidance. Citizens cannot distinguish urgent from routine, consequential from procedural, or trustworthy from speculative analysis.

2. **Fragmented Civic Engagement**: Existing platforms treat discovery, analysis, and action as separate workflows, forcing users to context-switch between tools. This fragmentation reduces engagement quality and makes sustained civic participation cognitively expensive.

3. **Trust and Verification Gaps**: Democratic discourse suffers when users cannot distinguish genuine expertise from confident ignorance, when financial conflicts remain obscured, and when information quality lacks systematic verification.

### Architectural Vision

The Chanuka UI architecture addresses these challenges through three foundational design principles:

**Progressive Disclosure Architecture**: Information reveals itself based on user need and context rather than overwhelming users with comprehensive data upfront. Reading time estimates, complexity indicators, and collapsible sections allow users to choose their engagement depth dynamically.

**Unified Civic Workflow**: Discovery, analysis, and action integrate into a coherent experience. Users transition fluidly from discovering relevant legislation to understanding implications to taking informed action, all within contextual workflows that maintain cognitive continuity.

**Transparent Intelligence Layer**: AI and algorithmic systems make their reasoning visible and contestable. Constitutional analysis shows its methodology. Conflict of interest detection explains what patterns trigger alerts. Expert verification displays credibility factors. This transparency builds trust while maintaining the benefits of computational analysis.

The architecture leverages existing infrastructure (design system, component library, performance monitoring) while introducing new patterns specifically designed for civic engagement at scale.

---

## High-Level System Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        A[Bills Dashboard] --> B[Bill Detail]
        A --> C[Search & Discovery]
        A --> D[Community Hub]
        A --> E[User Dashboard]
        B --> F[Constitutional Analysis]
        B --> G[Conflict Visualization]
        B --> H[Discussion Threads]
    end
    
    subgraph "State Management"
        I[Redux Store] --> J[UI State]
        I --> K[User Data]
        I --> L[Real-time Updates]
        I --> M[Cache Layer]
    end
    
    subgraph "Service Layer"
        N[REST API] --> O[Bill Service]
        N --> P[User Service]
        N --> Q[Analytics Service]
        R[WebSocket] --> S[Real-time Service]
        R --> T[Notification Service]
    end
    
    subgraph "Data Layer"
        U[PostgreSQL] --> V[Bills]
        U --> W[Users]
        U --> X[Engagement]
        Y[Redis] --> Z[Cache]
        Y --> AA[Sessions]
    end
    
    A --> I
    B --> I
    C --> I
    D --> I
    E --> I
    I --> N
    I --> R
    N --> U
    R --> U
    N --> Y
    R --> Y
    
    subgraph "Infrastructure"
        AB[CDN] --> AC[Static Assets]
        AD[Service Worker] --> AE[Offline Cache]
        AF[Analytics] --> AG[Performance Monitoring]
    end
    
    A --> AB
    A --> AD
    A --> AF
```

### Architecture Layers Explained

**Client Layer**: React-based single-page application with route-based code splitting. Each major view (Dashboard, Detail, Search, Community, User) loads as a separate bundle, minimizing initial load time while maintaining instant navigation through client-side routing.

**State Management**: Redux store manages application state with middleware for WebSocket integration, API calls, and cache synchronization. State shape optimizes for normalized data preventing duplication and enabling efficient updates.

**Service Layer**: RESTful API handles CRUD operations and complex queries. WebSocket service manages real-time updates for bill status changes, new comments, and engagement metrics. Services implement caching strategies and request batching for performance.

**Data Layer**: PostgreSQL provides primary data storage with full-text search capabilities. Redis handles session management, real-time data caching, and pub/sub for WebSocket broadcasting. Data layer implements proper indexing for query performance.

**Infrastructure**: CDN serves static assets with aggressive caching. Service Worker provides offline functionality and asset caching. Analytics monitor real user performance metrics for continuous optimization.

---

## Component Architecture

### Component Hierarchy

```typescript
// Core Layout Components
interface LayoutComponents {
  AppShell: {
    purpose: "Root layout with navigation, auth state, and error boundaries";
    props: {
      user: User | null;
      navigationItems: NavigationItem[];
      mobileBreakpoint: number;
    };
    children: "Route-specific views";
  };
  
  NavigationBar: {
    purpose: "Primary navigation with search, notifications, user menu";
    props: {
      currentRoute: string;
      notifications: Notification[];
      searchEnabled: boolean;
    };
    features: ["responsive collapse", "keyboard shortcuts", "skip links"];
  };
  
  PageLayout: {
    purpose: "Consistent page structure with header, content, sidebar";
    props: {
      header: ReactNode;
      sidebar?: ReactNode;
      sidebarPosition: "left" | "right";
      contentMaxWidth: string;
    };
    accessibility: "landmark regions, heading hierarchy";
  };
}

// Bills Dashboard Components
interface DashboardComponents {
  BillsDashboard: {
    purpose: "Main bills discovery interface";
    composition: [
      "StatsOverview",
      "QuickFilters",
      "AdvancedFilters",
      "BillsGrid",
      "Pagination"
    ];
    state: {
      filters: FilterState;
      sort: SortOptions;
      view: "grid" | "list";
    };
  };
  
  StatsOverview: {
    purpose: "High-level metrics for quick orientation";
    props: {
      totalBills: number;
      urgentCount: number;
      constitutionalFlags: number;
      trendingCount: number;
    };
    updates: "real-time via WebSocket";
  };
  
  BillCard: {
    purpose: "Individual bill display in dashboard";
    props: {
      bill: Bill;
      onSave: (billId: string) => void;
      onShare: (billId: string) => void;
      showQuickActions: boolean;
    };
    features: [
      "status indicator border",
      "urgency badge",
      "engagement metrics",
      "hover quick actions",
      "lazy image loading"
    ];
    accessibility: "keyboard navigation, screen reader labels";
  };
  
  FilterPanel: {
    purpose: "Multi-dimensional filtering interface";
    props: {
      availableFilters: FilterDefinition[];
      activeFilters: FilterState;
      onFilterChange: (filters: FilterState) => void;
      resultCounts: Record<string, number>;
    };
    responsive: {
      desktop: "sidebar panel";
      mobile: "bottom sheet drawer";
    };
  };
}

// Bill Detail Components
interface DetailComponents {
  BillDetailView: {
    purpose: "Comprehensive bill information display";
    composition: [
      "BillHeader",
      "QuickActionsBar",
      "TabbedContent",
      "ProgressiveNavigation"
    ];
    routing: "tabs update URL fragment for deep linking";
  };
  
  BillHeader: {
    purpose: "Bill identification and status";
    props: {
      bill: Bill;
      sponsors: Sponsor[];
      currentStatus: BillStatus;
      timeline: TimelineEvent[];
    };
    features: ["semantic HTML", "structured data markup"];
  };
  
  TabbedContent: {
    purpose: "Organized content with on-demand loading";
    props: {
      tabs: TabDefinition[];
      activeTab: string;
      onTabChange: (tabId: string) => void;
    };
    optimization: "lazy load tab content, cache viewed tabs";
    accessibility: "standard tab ARIA pattern";
  };
  
  ConstitutionalAnalysisPanel: {
    purpose: "Expert constitutional review integration";
    props: {
      analysis: ConstitutionalAnalysis;
      experts: ExpertContribution[];
      precedents: LegalPrecedent[];
      civicActions: CivicAction[];
    };
    features: [
      "severity color coding",
      "expert verification display",
      "expandable precedents",
      "actionable recommendations"
    ];
  };
  
  ConflictVisualization: {
    purpose: "Interactive conflict of interest mapping";
    props: {
      sponsor: Sponsor;
      financialData: FinancialExposure;
      connections: OrganizationalConnection[];
      votingPatterns: VotingPattern[];
    };
    visualization: "D3.js network graph with accessibility fallback";
    interactions: "node click, zoom, pan, keyboard navigation";
  };
}

// Community Components
interface CommunityComponents {
  DiscussionThread: {
    purpose: "Nested comment discussions";
    props: {
      comments: Comment[];
      maxDepth: number;
      sortBy: SortOption;
      onComment: (parentId: string, content: string) => void;
    };
    features: [
      "nested threading",
      "vote system",
      "expert highlight",
      "moderation tools",
      "real-time updates"
    ];
    accessibility: "keyboard navigation, thread depth announcement";
  };
  
  ExpertBadge: {
    purpose: "Display expert verification status";
    props: {
      expert: Expert;
      credibilityScore: number;
      showDetails: boolean;
    };
    features: [
      "verification level indicator",
      "tooltip with credentials",
      "credibility score display"
    ];
    accessibility: "ARIA label, keyboard accessible details";
  };
  
  EngagementAnalytics: {
    purpose: "Real-time participation metrics";
    props: {
      metrics: EngagementMetrics;
      updateInterval: number;
    };
    updates: "WebSocket subscription with fallback polling";
    visualization: "responsive charts using Recharts";
  };
}

// Shared UI Components
interface SharedComponents {
  ProgressiveNavigation: {
    purpose: "Reading guidance and quick jumps";
    props: {
      sections: Section[];
      currentSection: string;
      readingProgress: number;
    };
    features: [
      "complexity indicators",
      "reading time estimates",
      "progress bar",
      "quick jump links"
    ];
    responsive: {
      desktop: "sticky sidebar";
      mobile: "dropdown selector";
    };
  };
  
  SkeletonLoader: {
    purpose: "Loading state that matches content structure";
    props: {
      variant: "card" | "list" | "detail" | "chart";
      count?: number;
    };
    features: "prevents layout shift, accessible loading announcement";
  };
  
  ErrorBoundary: {
    purpose: "Graceful error handling with recovery";
    props: {
      fallback: ReactNode;
      onError: (error: Error, errorInfo: ErrorInfo) => void;
    };
    features: [
      "error logging",
      "user-friendly messages",
      "retry mechanisms",
      "navigation to safe state"
    ];
  };
}
```

---

## Data Models

### Core Data Structures

```typescript
// Bill Entity
interface Bill {
  id: string;
  billNumber: string;
  title: string;
  summary: string;
  fullText: string;
  status: BillStatus;
  urgencyLevel: UrgencyLevel;
  introducedDate: Date;
  lastUpdated: Date;
  
  // Relationships
  sponsors: Sponsor[];
  committees: Committee[];
  amendments: Amendment[];
  relatedBills: string[]; // Bill IDs
  
  // Analysis Data
  constitutionalFlags: ConstitutionalFlag[];
  pretextDetection: PretextAnalysis | null;
  impactAssessment: ImpactAssessment;
  
  // Engagement Data
  viewCount: number;
  saveCount: number;
  commentCount: number;
  shareCount: number;
  
  // Metadata
  policyAreas: string[];
  geographicScope: GeographicScope;
  complexity: ComplexityLevel;
  readingTime: ReadingTime;
}

enum BillStatus {
  PROPOSED = "proposed",
  COMMITTEE_REVIEW = "committee_review",
  FLOOR_DEBATE = "floor_debate",
  PASSED = "passed",
  REJECTED = "rejected",
  ENACTED = "enacted"
}

enum UrgencyLevel {
  CRITICAL = "critical",
  HIGH = "high",
  MEDIUM = "medium",
  LOW = "low"
}

interface ReadingTime {
  quick: number; // minutes for summary
  detailed: number; // minutes for detailed analysis
  comprehensive: number; // minutes for full content
}

// Sponsor and Conflict Analysis
interface Sponsor {
  id: string;
  name: string;
  title: string;
  party: string;
  constituency: string;
  profileImage: string;
  
  // Conflict Data
  financialExposure: FinancialExposure;
  organizationalConnections: OrganizationalConnection[];
  votingPatterns: VotingPattern[];
  transparencyScore: TransparencyScore;
  
  // Engagement
  billsSponsored: number;
  constitutionalFlags: number;
}

interface FinancialExposure {
  totalAmount: number;
  currency: string;
  breakdown: FinancialBreakdown[];
  lastDisclosure: Date;
  completeness: number; // 0-100 percentage
}

interface FinancialBreakdown {
  industry: string;
  amount: number;
  source: string;
  dateReceived: Date;
  disclosureStatus: "disclosed" | "partial" | "undisclosed";
}

interface OrganizationalConnection {
  organizationId: string;
  organizationName: string;
  connectionType: "employment" | "board_member" | "consultant" | "donor" | "family";
  startDate: Date;
  endDate: Date | null;
  description: string;
  relevantToPolicy: string[]; // Policy areas where conflict might exist
}

interface VotingPattern {
  policyArea: string;
  industryAlignment: number; // -1 to 1, negative opposes industry, positive aligns
  votesAnalyzed: number;
  confidence: number; // 0-1 statistical confidence
  significantVotes: Vote[];
}

interface TransparencyScore {
  overall: number; // 0-100
  factors: {
    disclosureCompleteness: number;
    timeliness: number;
    detailLevel: number;
    updateFrequency: number;
  };
  methodology: string;
  lastCalculated: Date;
}

// Constitutional Analysis
interface ConstitutionalFlag {
  id: string;
  severity: "critical" | "high" | "moderate" | "low";
  category: string; // e.g., "free_speech", "due_process", "equal_protection"
  description: string;
  affectedProvisions: BillProvision[];
  constitutionalReference: ConstitutionalReference[];
  expertAnalysis: ExpertAnalysis[];
  communityDiscussion: string; // Discussion thread ID
}

interface ConstitutionalReference {
  article: string;
  section: string;
  text: string;
  interpretation: string;
  relevantCases: LegalPrecedent[];
}

interface LegalPrecedent {
  caseName: string;
  year: number;
  jurisdiction: string;
  summary: string;
  relevance: string;
  outcome: string;
  fullCitation: string;
  url?: string;
}

// Expert Verification
interface Expert {
  userId: string;
  verificationType: "official" | "domain" | "identity";
  credentials: Credential[];
  affiliations: Affiliation[];
  specializations: string[];
  credibilityScore: number; // 0-100
  contributionCount: number;
  avgCommunityRating: number;
  verified: boolean;
  verificationDate: Date;
}

interface Credential {
  type: "education" | "certification" | "publication" | "experience";
  institution: string;
  title: string;
  year: number;
  verified: boolean;
}

interface Affiliation {
  organization: string;
  role: string;
  startDate: Date;
  endDate: Date | null;
  conflictPotential: boolean;
  conflictDescription?: string;
}

interface ExpertAnalysis {
  id: string;
  expertId: string;
  expert: Expert;
  billId: string;
  category: string;
  analysis: string; // Rich text content
  citations: Citation[];
  createdAt: Date;
  updatedAt: Date;
  upvotes: number;
  downvotes: number;
  communityValidation: CommunityValidation;
}

interface CommunityValidation {
  helpful: number;
  wellSupported: number;
  disagree: number;
  avgRating: number;
  reviewCount: number;
}

// Community Engagement
interface Comment {
  id: string;
  parentId: string | null;
  billId: string;
  userId: string;
  user: User;
  content: string; // Sanitized HTML
  createdAt: Date;
  updatedAt: Date;
  depth: number; // Thread nesting level
  upvotes: number;
  downvotes: number;
  flagged: boolean;
  moderationStatus: ModerationStatus;
}

enum ModerationStatus {
  APPROVED = "approved",
  PENDING = "pending",
  FLAGGED = "flagged",
  REMOVED = "removed"
}

interface EngagementMetrics {
  billId: string;
  timeframe: "hour" | "day" | "week";
  metrics: {
    views: number;
    uniqueViews: number;
    comments: number;
    saves: number;
    shares: number;
    expertContributions: number;
  };
  sentiment: SentimentBreakdown;
  participantCount: number;
  expertParticipation: number;
  trendDirection: "up" | "down" | "stable";
}

interface SentimentBreakdown {
  positive: number; // percentage
  neutral: number;
  concerned: number;
  opposed: number;
}

// User Data
interface User {
  id: string;
  email: string;
  displayName: string;
  avatar: string;
  role: UserRole;
  
  // Preferences
  preferences: UserPreferences;
  notificationSettings: NotificationSettings;
  privacySettings: PrivacySettings;
  
  // Engagement
  trackedBills: string[]; // Bill IDs
  engagementHistory: EngagementHistory;
  civicScore: CivicScore;
  
  // Authentication
  lastLogin: Date;
  twoFactorEnabled: boolean;
  emailVerified: boolean;
}

enum UserRole {
  ANONYMOUS = "anonymous",
  USER = "user",
  VERIFIED_EXPERT = "verified_expert",
  MODERATOR = "moderator",
  ADMIN = "admin"
}

interface UserPreferences {
  theme: "light" | "dark" | "auto";
  language: string;
  policyAreas: string[];
  geographicFocus: string[];
  dashboardLayout: string;
  defaultBillView: "grid" | "list";
  defaultSort: SortOption;
}

interface NotificationSettings {
  channels: {
    inApp: boolean;
    email: boolean;
    sms: boolean;
  };
  frequency: {
    immediate: string[]; // Notification types
    daily: string[];
    weekly: string[];
  };
  quietHours: {
    enabled: boolean;
    start: string; // 24-hour time
    end: string;
  };
}

interface EngagementHistory {
  billsViewed: BillInteraction[];
  commentsPosted: number;
  votescast: number;
  sharesCreated: number;
  joinDate: Date;
  lastActive: Date;
}

interface CivicScore {
  overall: number; // 0-100
  factors: {
    participation: number;
    quality: number;
    consistency: number;
    diversity: number;
  };
  level: "emerging" | "active" | "dedicated" | "champion";
  nextMilestone: Milestone;
}
```

---

## State Management Architecture

### Redux Store Structure

```typescript
interface RootState {
  // UI State
  ui: {
    loading: LoadingState;
    errors: ErrorState;
    modals: ModalState;
    navigation: NavigationState;
  };
  
  // Data State
  bills: {
    byId: Record<string, Bill>;
    allIds: string[];
    filters: FilterState;
    sort: SortOptions;
    pagination: PaginationState;
  };
  
  sponsors: {
    byId: Record<string, Sponsor>;
    allIds: string[];
  };
  
  comments: {
    byId: Record<string, Comment>;
    byBillId: Record<string, string[]>; // Bill ID to comment IDs
  };
  
  experts: {
    byId: Record<string, Expert>;
    analyses: Record<string, ExpertAnalysis[]>; // Bill ID to analyses
  };
  
  // User State
  auth: {
    user: User | null;
    token: string | null;
    isAuthenticated: boolean;
    loading: boolean;
  };
  
  userDashboard: {
    trackedBills: string[];
    recentActivity: Activity[];
    recommendations: Recommendation[];
    civicScore: CivicScore;
  };
  
  // Real-time State
  realtime: {
    connected: boolean;
    subscriptions: string[]; // Bill IDs subscribed to
    pendingUpdates: Update[];
  };
  
  // Cache State
  cache: {
    billDetails: Record<string, CacheEntry>;
    searchResults: Record<string, CacheEntry>;
    expirationTimes: Record<string, number>;
  };
}

interface LoadingState {
  global: boolean;
  bills: boolean;
  billDetail: boolean;
  comments: boolean;
  search: boolean;
}

interface ErrorState {
  global: Error | null;
  bills: Error | null;
  billDetail: Error | null;
  comments: Error | null;
}

interface FilterState {
  billType: string[];
  policyAreas: string[];
  sponsors: string[];
  timeframe: {
    start: Date | null;
    end: Date | null;
  };
  urgencyLevels: UrgencyLevel[];
  controversyLevels: string[];
  constitutionalFlags: boolean;
  geographicScope: string[];
}

interface CacheEntry {
  data: any;
  timestamp: number;
  expiresAt: number;
}
```

### State Update Patterns

```typescript
// Redux Actions - Normalized Data Pattern
const billsSlice = createSlice({
  name: 'bills',
  initialState: {
    byId: {},
    allIds: [],
    loading: false,
    error: null
  },
  reducers: {
    // Normalized data updates
    billsReceived: (state, action: PayloadAction<Bill[]>) => {
      const normalized = normalizeBills(action.payload);
      state.byId = { ...state.byId, ...normalized.byId };
      state.allIds = [...new Set([...state.allIds, ...normalized.allIds])];
    },
    
    billUpdated: (state, action: PayloadAction<Bill>) => {
      state.byId[action.payload.id] = action.payload;
    },
    
    // Real-time update
    billStatusChanged: (state, action: PayloadAction<{billId: string, status: BillStatus}>) => {
      const bill = state.byId[action.payload.billId];
      if (bill) {
        bill.status = action.payload.status;
        bill.lastUpdated = new Date();
      }
    }
  }
});

// Selectors with Memoization
const selectBillById = (state: RootState, billId: string) => 
  state.bills.byId[billId];

const selectFilteredBills = createSelector(
  [
    (state: RootState) => state.bills.byId,
    (state: RootState) => state.bills.allIds,
    (state: RootState) => state.bills.filters
  ],
  (byId, allIds, filters) => {
    return allIds
      .map(id => byId[id])
      .filter(bill => applyFilters(bill, filters));
  }
);

const selectBillWithSponsors = createSelector(
  [selectBillById, (state: RootState) => state.sponsors.byId],
  (bill, sponsors) => {
    if (!bill) return null;
    return {
      ...bill,
      sponsors: bill.sponsors.map(sponsorId => sponsors[sponsorId])
    };
  }
);
```

---

## Error Handling Strategy

### Hierarchical Error Management

```typescript
// Error Types
enum ErrorSeverity {
  CRITICAL = "critical", // App cannot function
  HIGH = "high",          // Feature unavailable
  MEDIUM = "medium",      // Degraded experience
  LOW = "low"            // Minor issue, user can continue
}

interface AppError {
  severity: ErrorSeverity;
  code: string;
  message: string;
  userMessage: string;
  timestamp: Date;
  context?: Record<string, any>;
  recoverable: boolean;
  recovery?: () => void;
}

// Error Boundary Pattern
class FeatureErrorBoundary extends React.Component<Props, State> {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log to monitoring service
    logError({
      error,
      errorInfo,
      severity: this.determineSeverity(error),
      userContext: this.props.user
    });
  }
  
  determineSeverity(error: Error): ErrorSeverity {
    if (error instanceof NetworkError) return ErrorSeverity.MEDIUM;
    if (error instanceof AuthenticationError) return ErrorSeverity.HIGH;
    return ErrorSeverity.LOW;
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <ErrorFallback
          error={this.state.error}
          onRetry={() => this.setState({ hasError: false, error: null })}
          onNavigate={() => window.location.href = '/'}
        />
      );
    }
    return this.props.children;
  }
}

// Recovery Mechanisms
const errorRecoveryStrategies = {
  NetworkError: {
    retry: true,
    retryDelay: [1000, 2000, 5000], // Exponential backoff
    fallback: () => loadCachedData(),
    userMessage: "Connection issue. Retrying..."
  },
  
  AuthenticationError: {
    retry: false,
    fallback: () => redirectToLogin(),
    userMessage: "Please sign in again to continue"
  },
  
  ValidationError: {
    retry: false,
    fallback: () => showValidationFeedback(),
    userMessage: "Please check your input and try again"
  },
  
  ServerError: {
    retry: true,
    retryDelay: [2000, 5000, 10000],
    fallback: () => showGracefulDegradation(),
    userMessage: "Server issue. We're working on it..."
  }
};

// Graceful Degradation
interface FallbackStrategy {
  component: React.ComponentType;
  data: any;
  limitations: string[];
}

const fallbackStrategies: Record<string, FallbackStrategy> = {
  BillDetail: {
    component: SimpleBillView,
    data: () => loadCachedBillData(),
    limitations: ["Real-time updates unavailable", "Comments view only"]
  },
  
  Search: {
    component: BasicSearch,
    data: () => loadRecentBills(),
    limitations: ["Advanced filters unavailable", "Results may be cached"]
  },
  
  ConflictVisualization: {
    component: TableView,
    data: (props) => props.sponsor.financialData,
    limitations: ["Interactive visualization unavailable"]
  }
};
```

---

## Testing Strategy

### Testing Pyramid

```typescript
// Unit Tests - Component Behavior
describe('BillCard', () => {
  it('displays bill information correctly', () => {
    const bill = createMockBill();
    const { getByText, getByRole } = render(<BillCard bill={bill} />);
    
    expect(getByText(bill.title)).toBeInTheDocument();
    expect(getByRole('article')).toHaveAttribute('aria-label', `Bill: ${bill.title}`);
  });
  
  it('shows urgency badge when bill is critical', () => {
    const criticalBill = createMockBill({ urgencyLevel: 'critical' });
    const { getByText } = render(<BillCard bill={criticalBill} />);
    
    expect(getByText('Critical')).toBeInTheDocument();
  });
  
  it('calls onSave when save button clicked', () => {
    const bill = createMockBill();
    const onSave = jest.fn();
    const { getByRole } = render(<BillCard bill={bill} onSave={onSave} />);
    
    fireEvent.click(getByRole('button', { name: /save/i }));
    expect(onSave).toHaveBeenCalledWith(bill.id);
  });
});

// Integration Tests - Feature Workflows
describe('Bill Discovery Workflow', () => {
  it('allows filtering and viewing bill details', async () => {
    const { user } = setup(<BillsDashboard />);
    
    // Apply filter
    await user.click(screen.getByRole('button', { name: /filters/i }));
    await user.click(screen.getByLabelText('Health Policy'));
    await user.click(screen.getByRole('button', { name: /apply/i }));
    
    // Verify filtered results
    await waitFor(() => {
      expect(screen.getAllByRole('article')).toHaveLength(5);
    });
    
    // Navigate to detail
    await user.click(screen.getByText('Healthcare Reform Act'));
    
    // Verify detail page loaded
    expect(screen.getByRole('heading', { level: 1 })).toHaveTextContent('Healthcare Reform Act');
  });
});

// Accessibility Tests
describe('Accessibility Compliance', () => {
  it('has no accessibility violations', async () => {
    const { container } = render(<BillsDashboard />);
    const results = await axe(container);
    
    expect(results).toHaveNoViolations();
  });
  
  it('supports keyboard navigation', async () => {
    const { user } = setup(<BillCard bill={mockBill} />);
    
    // Tab to card
    await user.tab();
    expect(screen.getByRole('article')).toHaveFocus();
    
    // Tab to save button
    await user.tab();
    expect(screen.getByRole('button', { name: /save/i })).toHaveFocus();
    
    // Activate with Enter
    await user.keyboard('{Enter}');
    expect(mockOnSave).toHaveBeenCalled();
  });
  
  it('announces dynamic content to screen readers', async () => {
    const { rerender } = render(<StatsOverview stats={initialStats} />);
    
    const liveRegion = screen.getByRole('status');
    expect(liveRegion).toHaveAttribute('aria-live', 'polite');
    
    // Update stats
    rerender(<StatsOverview stats={updatedStats} />);
    
    expect(liveRegion).toHaveTextContent('Stats updated: 156 active bills');
  });
});

// Performance Tests
describe('Performance Benchmarks', () => {
  it('renders dashboard within performance budget', async () => {
    const startTime = performance.now();
    
    render(<BillsDashboard bills={largeBillsDataset} />);
    
    const renderTime = performance.now() - startTime;
    expect(renderTime).toBeLessThan(100); // 100ms budget
  });
  
  it('lazy loads below-fold content', () => {
    const { container } = render(<BillsGrid bills={manyBills} />);
    
    const billCards = container.querySelectorAll('[data-testid="bill-card"]');
    const aboveFold = Array.from(billCards).slice(0, 6);
    const belowFold = Array.from(billCards).slice(6);
    
    // Above-fold images should have src
    aboveFold.forEach(card => {
      const img = card.querySelector('img');
      expect(img).toHaveAttribute('src');
    });
    
    // Below-fold images should use loading="lazy"
    belowFold.forEach(card => {
      const img = card.querySelector('img');
      expect(img).toHaveAttribute('loading', 'lazy');
    });
  });
});

// Real-time Integration Tests
describe('WebSocket Real-time Updates', () => {
  it('receives and displays bill status updates', async () => {
    const { mockSocket } = setupWebSocketTest();
    render(<BillDetailView billId="123" />);
    
    // Simulate WebSocket message
    act(() => {
      mockSocket.emit('bill:status-changed', {
        billId: '123',
        status: 'passed',
        timestamp: new Date()
      });
    });
    
    await waitFor(() => {
      expect(screen.getByText('Status: Passed')).toBeInTheDocument();
    });
  });
  
  it('falls back to polling when WebSocket unavailable', async () => {
    const { mockFetch } = setupMockFetch();
    setupWebSocketTest({ failConnection: true });
    
    render(<BillDetailView billId="123" />);
    
    // Wait for fallback polling
    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/bills/123'),
        expect.any(Object)
      );
    }, { timeout: 11000 }); // 10s polling interval + buffer
  });
});
```

---

## Implementation Phases

### Phase 1: Foundation (Weeks 1-4)

**Objective**: Establish core infrastructure and basic bill discovery functionality

**Deliverables**:
- Application shell with routing
- Bills dashboard with basic display
- Bill detail page skeleton
- Design system integration
- Authentication flow
- Basic mobile responsiveness

**Success Criteria**:
- Users can browse bills in responsive grid
- Navigation works across desktop/tablet/mobile
- Basic bill information displays correctly
- Performance meets Core Web Vitals baseline (LCP < 3s)
- Authentication protects user-specific features

**Technical Tasks**:
```typescript
// Phase 1 Component Checklist
const phase1Components = {
  infrastructure: [
    'AppShell with error boundaries',
    'Redux store configuration',
    'API service layer',
    'Authentication service',
    'Route configuration'
  ],
  
  dashboard: [
    'BillsDashboard container',
    'BillCard component',
    'StatsOverview component',
    'Basic filter panel',
    'Pagination component'
  ],
  
  detail: [
    'BillDetailView container',
    'BillHeader component',
    'TabbedContent component',
    'Overview tab content',
    'Full text display'
  ],
  
  shared: [
    'NavigationBar',
    'LoadingSpinner',
    'SkeletonLoader variants',
    'ErrorFallback',
    'Button, Card, Badge components'
  ]
};
```

**Testing Requirements**:
- Unit tests for all components (80% coverage minimum)
- Integration tests for authentication flow
- Accessibility audit with automated tools
- Performance baseline measurement
- Cross-browser testing (Chrome, Firefox, Safari, Edge)

---

### Phase 2: Advanced Discovery (Weeks 5-8)

**Objective**: Implement sophisticated filtering, search, and navigation patterns

**Deliverables**:
- Advanced filtering system
- Multi-engine search
- Progressive disclosure navigation
- Complexity indicators and reading paths
- Enhanced bill cards with quick actions
- Real-time statistics updates

**Success Criteria**:
- Users can apply complex multi-dimensional filters
- Search returns relevant results in <500ms
- Progressive navigation guides users through content
- Real-time updates work via WebSocket
- Mobile filtering uses bottom sheet pattern

**Technical Tasks**:
```typescript
const phase2Components = {
  discovery: [
    'AdvancedFilterPanel',
    'FilterChips with removal',
    'SearchInterface with autocomplete',
    'SearchResults with highlighting',
    'SavedSearches component'
  ],
  
  navigation: [
    'ProgressiveNavigation component',
    'ComplexityIndicators',
    'ReadingTimeEstimates',
    'SectionNavigator',
    'ProgressBar'
  ],
  
  realtime: [
    'WebSocket service integration',
    'Real-time stats updates',
    'Connection status indicator',
    'Fallback polling mechanism'
  ],
  
  enhancement: [
    'BillCard hover actions',
    'Quick save/share/comment',
    'Engagement metrics display',
    'Lazy image loading'
  ]
};
```

**Testing Requirements**:
- Search relevance testing with sample queries
- Filter combination testing (all permutations)
- WebSocket connection/reconnection testing
- Performance testing with large datasets
- Mobile gesture testing on actual devices

---

### Phase 3: Analysis and Transparency (Weeks 9-12)

**Objective**: Integrate constitutional analysis and conflict of interest features

**Deliverables**:
- Constitutional analysis panel
- Expert verification system
- Conflict of interest visualization
- Sponsor network graphs
- Pretext detection interface
- Expert contribution display

**Success Criteria**:
- Constitutional flags display with expert analysis
- Interactive conflict visualization works on all devices
- Expert badges and credibility scores show correctly
- Network graphs are accessible via keyboard
- Analysis updates in real-time

**Technical Tasks**:
```typescript
const phase3Components = {
  analysis: [
    'ConstitutionalAnalysisPanel',
    'ExpertAnalysisCard',
    'PretextDetectionInterface',
    'LegalPrecedentDisplay',
    'CivicActionGuidance'
  ],
  
  transparency: [
    'ConflictVisualization (D3.js)',
    'FinancialExposureBreakdown',
    'OrganizationalConnectionsGraph',
    'VotingPatternChart',
    'TransparencyScoreDisplay'
  ],
  
  expertise: [
    'ExpertBadge component',
    'ExpertProfileCard',
    'CredibilityScoreDisplay',
    'CommunityValidationIndicator',
    'ExpertVerificationFlow'
  ],
  
  accessibility: [
    'Visualization keyboard navigation',
    'Screen reader descriptions for charts',
    'Alternative table views for visualizations',
    'Focus management in complex widgets'
  ]
};
```

**Testing Requirements**:
- Visualization interaction testing
- Accessibility testing for complex widgets
- Expert verification workflow testing
- Data visualization accuracy validation
- Performance testing for network graphs

---

### Phase 4: Community and Engagement (Weeks 13-16)

**Objective**: Build community features and engagement tools

**Deliverables**:
- Discussion threading system
- Community hub with activity feed
- Engagement analytics dashboard
- Notification system (in-app, email, SMS)
- User dashboard with personalization
- Moderation tools

**Success Criteria**:
- Nested discussions work to 5 levels deep
- Real-time comments appear without refresh
- Notifications deliver through configured channels
- User dashboard shows personalized content
- Moderation workflow functions efficiently

**Technical Tasks**:
```typescript
const phase4Components = {
  community: [
    'DiscussionThread component',
    'CommentForm with validation',
    'CommentCard with voting',
    'ThreadCollapse/Expand',
    'ModeratorTools'
  ],
  
  engagement: [
    'CommunityHub container',
    'ActivityFeed component',
    'TrendingTopics display',
    'EngagementAnalytics charts',
    'ActionCenter'
  ],
  
  notifications: [
    'NotificationCenter',
    'NotificationBadge',
    'NotificationPreferences',
    'EmailDigestSettings',
    'InAppToast'
  ],
  
  personalization: [
    'UserDashboard container',
    'TrackedBills widget',
    'EngagementHistory display',
    'RecommendationsPanel',
    'CivicScoreCard'
  ]
};
```

**Testing Requirements**:
- Comment threading display testing
- Real-time comment updates testing
- Notification delivery across channels
- Moderation workflow testing
- Personalization algorithm validation

---

## Migration Strategy

### Progressive Enhancement Approach

The migration strategy ensures backward compatibility while progressively introducing new features:

**Stage 1: Parallel Operation**
```typescript
// Feature flag system for gradual rollout
interface FeatureFlags {
  newDashboard: boolean;
  advancedFilters: boolean;
  constitutionalAnalysis: boolean;
  conflictVisualization: boolean;
  communityFeatures: boolean;
  realTimeUpdates: boolean;
}

// Component-level feature detection
const BillsDashboard: React.FC = () => {
  const flags = useFeatureFlags();
  
  return flags.newDashboard ? (
    <EnhancedBillsDashboard />
  ) : (
    <LegacyBillsDashboard />
  );
};
```

**Stage 2: Data Migration**
```typescript
// Gradual data structure migration
interface MigrationPlan {
  phase1: {
    description: "Add new fields to existing tables";
    changes: [
      "Add urgencyLevel to bills table",
      "Add readingTime JSON column",
      "Create constitutional_flags table"
    ];
    rollback: "New fields nullable, system works without them";
  };
  
  phase2: {
    description: "Migrate existing data to new structures";
    process: "Background job processes existing bills";
    verification: "Dual-write ensures consistency";
    rollback: "Keep old data structures until verification complete";
  };
  
  phase3: {
    description: "Switch to new structures exclusively";
    trigger: "After 95% migration completion";
    verification: "Automated testing validates all features";
    rollback: "Feature flags revert to legacy components";
  };
}
```

**Stage 3: User Migration**
```typescript
// Gradual user rollout
const rolloutStrategy = {
  week1: {
    audience: "Internal team",
    percentage: 5,
    monitoring: "Intensive error tracking, performance monitoring"
  },
  
  week2: {
    audience: "Beta users (opted in)",
    percentage: 10,
    monitoring: "User feedback collection, usability testing"
  },
  
  week3: {
    audience: "Power users (high engagement)",
    percentage: 25,
    monitoring: "Feature usage analytics, satisfaction surveys"
  },
  
  week4: {
    audience: "All users",
    percentage: 100,
    monitoring: "Standard monitoring, support ticket tracking"
  }
};
```

**Stage 4: Legacy Cleanup**
```typescript
// Post-migration cleanup timeline
const cleanupPhases = {
  immediate: [
    "Remove feature flags for stable features",
    "Archive legacy components",
    "Update documentation"
  ],
  
  oneMonth: [
    "Drop old database columns",
    "Remove legacy API endpoints",
    "Clean up unused dependencies"
  ],
  
  threeMonths: [
    "Complete technical debt cleanup",
    "Performance optimization",
    "Code quality improvements"
  ]
};
```

---

## Performance Optimization Strategy

### Critical Rendering Path

```typescript
// Performance budget enforcement
const performanceBudgets = {
  javascript: {
    main: 100, // KB gzipped
    route: 50,  // KB per route bundle
    total: 300  // KB total JS
  },
  
  css: {
    critical: 14, // KB inline critical CSS
    total: 50     // KB total CSS
  },
  
  images: {
    hero: 100,    // KB for hero images
    card: 20,     // KB for card thumbnails
    icon: 2       // KB for icons
  },
  
  fonts: {
    total: 100    // KB for all font files
  }
};

// Code splitting strategy
const routeCodeSplitting = {
  '/': () => import('./pages/BillsDashboard'),
  '/bills/:id': () => import('./pages/BillDetail'),
  '/search': () => import('./pages/Search'),
  '/community': () => import('./pages/CommunityHub'),
  '/dashboard': () => import('./pages/UserDashboard')
};

// Component lazy loading
const LazyConflictVisualization = lazy(() => 
  import('./components/ConflictVisualization')
);

const BillDetailView = () => {
  const [showVisualization, setShowVisualization] = useState(false);
  
  return (
    <>
      {/* Critical content loads immediately */}
      <BillHeader />
      <BillContent />
      
      {/* Heavy visualization loads on demand */}
      {showVisualization && (
        <Suspense fallback={<SkeletonLoader variant="chart" />}>
          <LazyConflictVisualization />
        </Suspense>
      )}
    </>
  );
};
```

### Resource Loading Strategy

```typescript
// Preload critical resources
const resourceHints = `
  <!-- DNS prefetch for API -->
  <link rel="dns-prefetch" href="https://api.chanuka.ke">
  
  <!-- Preconnect for CDN -->
  <link rel="preconnect" href="https://cdn.chanuka.ke">
  
  <!-- Preload critical font -->
  <link rel="preload" href="/fonts/inter-var.woff2" as="font" type="font/woff2" crossorigin>
  
  <!-- Preload critical CSS -->
  <link rel="preload" href="/css/critical.css" as="style">
`;

// Lazy loading images
const OptimizedImage: React.FC<ImageProps> = ({ src, alt, priority }) => {
  return (
    <img
      src={priority ? src : undefined}
      data-src={priority ? undefined : src}
      alt={alt}
      loading={priority ? "eager" : "lazy"}
      decoding="async"
      className="optimized-image"
    />
  );
};

// Service worker caching strategy
const cachingStrategy = {
  static: {
    // Cache static assets aggressively
    pattern: /\.(js|css|woff2|png|svg)$/,
    strategy: 'CacheFirst',
    expiration: {
      maxEntries: 100,
      maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
    }
  },
  
  api: {
    // Network first for API, fall back to cache
    pattern: /\/api\//,
    strategy: 'NetworkFirst',
    expiration: {
      maxEntries: 50,
      maxAgeSeconds: 5 * 60 // 5 minutes
    }
  },
  
  bills: {
    // Stale-while-revalidate for bill content
    pattern: /\/api\/bills\//,
    strategy: 'StaleWhileRevalidate',
    expiration: {
      maxEntries: 30,
      maxAgeSeconds: 60 * 60 // 1 hour
    }
  }
};
```

### Rendering Optimization

```typescript
// Virtual scrolling for large lists
const VirtualBillsList: React.FC<{ bills: Bill[] }> = ({ bills }) => {
  const parentRef = useRef<HTMLDivElement>(null);
  
  const rowVirtualizer = useVirtualizer({
    count: bills.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 200, // Estimated row height
    overscan: 5 // Render 5 items above/below viewport
  });
  
  return (
    <div ref={parentRef} className="bills-list-container">
      <div style={{ height: `${rowVirtualizer.getTotalSize()}px` }}>
        {rowVirtualizer.getVirtualItems().map(virtualRow => (
          <BillCard
            key={bills[virtualRow.index].id}
            bill={bills[virtualRow.index]}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              transform: `translateY(${virtualRow.start}px)`
            }}
          />
        ))}
      </div>
    </div>
  );
};

// Memoization for expensive computations
const BillCard: React.FC<BillCardProps> = memo(({ bill, onSave }) => {
  // Component memoizes to prevent unnecessary re-renders
  const formattedDate = useMemo(
    () => formatDate(bill.introducedDate),
    [bill.introducedDate]
  );
  
  const handleSave = useCallback(
    () => onSave(bill.id),
    [bill.id, onSave]
  );
  
  return (
    <article className="bill-card">
      <h3>{bill.title}</h3>
      <time dateTime={bill.introducedDate.toISOString()}>
        {formattedDate}
      </time>
      <button onClick={handleSave}>Save</button>
    </article>
  );
}, (prevProps, nextProps) => {
  // Custom comparison for memo
  return prevProps.bill.id === nextProps.bill.id &&
         prevProps.bill.lastUpdated === nextProps.bill.lastUpdated;
});
```

---

## Security Implementation

### Content Security Policy

```typescript
// CSP Headers Configuration
const cspDirectives = {
  "default-src": ["'self'"],
  "script-src": [
    "'self'",
    "'nonce-{NONCE}'", // Dynamic nonce for inline scripts
    "https://cdn.chanuka.ke"
  ],
  "style-src": [
    "'self'",
    "'unsafe-inline'", // Required for styled-components
    "https://cdn.chanuka.ke"
  ],
  "img-src": [
    "'self'",
    "data:",
    "https:",
    "blob:"
  ],
  "font-src": [
    "'self'",
    "data:",
    "https://cdn.chanuka.ke"
  ],
  "connect-src": [
    "'self'",
    "https://api.chanuka.ke",
    "wss://ws.chanuka.ke"
  ],
  "frame-ancestors": ["'none'"],
  "base-uri": ["'self'"],
  "form-action": ["'self'"]
};

// XSS Prevention
const sanitizeUserContent = (content: string): string => {
  // Use DOMPurify for HTML sanitization
  return DOMPurify.sanitize(content, {
    ALLOWED_TAGS: [
      'p', 'br', 'strong', 'em', 'u', 'a', 'ul', 'ol', 'li', 'blockquote'
    ],
    ALLOWED_ATTR: ['href', 'title', 'target'],
    ALLOW_DATA_ATTR: false
  });
};

// CSRF Protection
const csrfProtection = {
  // Token in meta tag
  getToken: () => document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'),
  
  // Include in all mutation requests
  addToRequest: (config: RequestConfig) => ({
    ...config,
    headers: {
      ...config.headers,
      'X-CSRF-Token': csrfProtection.getToken()
    }
  })
};
```

### Input Validation

```typescript
// Zod schemas for runtime validation
const CommentSchema = z.object({
  content: z.string()
    .min(50, "Comment must be at least 50 characters")
    .max(5000, "Comment cannot exceed 5000 characters")
    .refine(content => !/<script/i.test(content), "Script tags not allowed"),
  
  billId: z.string().uuid("Invalid bill ID"),
  
  parentId: z.string().uuid("Invalid parent comment ID").optional()
});

const FilterSchema = z.object({
  billType: z.array(z.string()).max(10),
  policyAreas: z.array(z.string()).max(10),
  urgencyLevels: z.array(z.enum(['critical', 'high', 'medium', 'low'])),
  timeframe: z.object({
    start: z.date().optional(),
    end: z.date().optional()
  }).refine(data => {
    if (data.start && data.end) {
      return data.start <= data.end;
    }
    return true;
  }, "End date must be after start date")
});

// Validation in components
const CommentForm: React.FC = () => {
  const handleSubmit = async (formData: unknown) => {
    try {
      const validated = CommentSchema.parse(formData);
      await postComment(validated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        showValidationErrors(error.errors);
      }
    }
  };
};
```

---

## Monitoring and Observability

### Performance Monitoring

```typescript
// Web Vitals tracking
const trackWebVitals = () => {
  // Core Web Vitals
  onLCP(metric => {
    analytics.track('Performance', {
      metric: 'LCP',
      value: metric.value,
      rating: metric.rating,
      route: window.location.pathname
    });
  });
  
  onFID(metric => {
    analytics.track('Performance', {
      metric: 'FID',
      value: metric.value,
      rating: metric.rating,
      route: window.location.pathname
    });
  });
  
  onCLS(metric => {
    analytics.track('Performance', {
      metric: 'CLS',
      value: metric.value,
      rating: metric.rating,
      route: window.location.pathname
    });
  });
  
  // Custom metrics
  onTTFB(metric => {
    analytics.track('Performance', {
      metric: 'TTFB',
      value: metric.value,
      route: window.location.pathname
    });
  });
};

// Performance budget alerts
const checkPerformanceBudget = (metric: Metric) => {
  const budgets = {
    LCP: 2500,
    FID: 100,
    CLS: 0.1
  };
  
  if (metric.value > budgets[metric.name]) {
    alert({
      severity: 'warning',
      message: `${metric.name} exceeded budget`,
      value: metric.value,
      budget: budgets[metric.name],
      route: window.location.pathname
    });
  }
};
```

### Error Monitoring

```typescript
// Structured error logging
const logError = (error: AppError) => {
  const errorData = {
    message: error.message,
    severity: error.severity,
    code: error.code,
    timestamp: error.timestamp,
    
    // User context
    userId: getCurrentUser()?.id,
    userRole: getCurrentUser()?.role,
    
    // Technical context
    route: window.location.pathname,
    userAgent: navigator.userAgent,
    viewport: {
      width: window.innerWidth,
      height: window.innerHeight
    },
    
    // Application state
    reduxState: store.getState(),
    
    // Stack trace
    stack: error.stack,
    
    // Additional context
    context: error.context
  };
  
  // Send to monitoring service
  errorTracking.captureException(errorData);
  
  // Log to console in development
  if (process.env.NODE_ENV === 'development') {
    console.error('Application Error:', errorData);
  }
};

// User interaction tracking
const trackUserFlow = () => {
  // Track key user actions
  const events = {
    billViewed: (billId: string) => analytics.track('Bill Viewed', { billId }),
    billSaved: (billId: string) => analytics.track('Bill Saved', { billId }),
    commentPosted: (billId: string, length: number) => 
      analytics.track('Comment Posted', { billId, length }),
    filterApplied: (filters: FilterState) => 
      analytics.track('Filter Applied', { filterCount: Object.keys(filters).length }),
    searchPerformed: (query: string, resultCount: number) =>
      analytics.track('Search Performed', { queryLength: query.length, resultCount })
  };
  
  return events;
};
```

---

## Accessibility Implementation Details

### ARIA Patterns

```typescript
// Tab panel pattern
const TabbedContent: React.FC<TabbedContentProps> = ({ tabs }) => {
  const [activeTab, setActiveTab] = useState(tabs[0].id);
  
  return (
    <div className="tabbed-content">
      <div role="tablist" aria-label="Bill information">
        {tabs.map((tab, index) => (
          <button
            key={tab.id}
            role="tab"
            id={`tab-${tab.id}`}
            aria-controls={`panel-${tab.id}`}
            aria-selected={activeTab === tab.id}
            tabIndex={activeTab === tab.id ? 0 : -1}
            onClick={() => setActiveTab(tab.id)}
            onKeyDown={(e) => handleTabKeyboard(e, index)}
          >
            {tab.label}
          </button>
        ))}
      </div>
      
      {tabs.map(tab => (
        <div
          key={tab.id}
          role="tabpanel"
          id={`panel-${tab.id}`}
          aria-labelledby={`tab-${tab.id}`}
          hidden={activeTab !== tab.id}
          tabIndex={0}
        >
          {tab.content}
        </div>
      ))}
    </div>
  );
};

// Disclosure pattern for collapsible sections
const CollapsibleSection: React.FC<CollapsibleProps> = ({ title, children }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const contentId = useId();
  
  return (
    <div className="collapsible-section">
      <button
        aria-expanded={isExpanded}
        aria-controls={contentId}
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <span>{title}</span>
        <ChevronIcon direction={isExpanded ? 'up' : 'down'} aria-hidden="true" />
      </button>
      
      <div
        id={contentId}
        hidden={!isExpanded}
        role="region"
        aria-labelledby={`heading-${contentId}`}
      >
        {children}
      </div>
    </div>
  );
};

// Live region for dynamic updates
const LiveUpdateAnnouncer: React.FC = () => {
  const [announcement, setAnnouncement] = useState('');
  
  useEffect(() => {
    const handleBillUpdate = (event: CustomEvent) => {
      setAnnouncement(
        `Bill ${event.detail.billNumber} status changed to ${event.detail.status}`
      );
      
      // Clear announcement after screen reader processes it
      setTimeout(() => setAnnouncement(''), 1000);
    };
    
    window.addEventListener('bill-updated', handleBillUpdate);
    return () => window.removeEventListener('bill-updated', handleBillUpdate);
  }, []);
  
  return (
    <div
      role="status"
      aria-live="polite"
      aria-atomic="true"
      className="sr-only"
    >
      {announcement}
    </div>
  );
};
```

### Keyboard Navigation

```typescript
// Focus management utilities
const focusManagement = {
  // Trap focus within modal
  trapFocus: (element: HTMLElement) => {
    const focusableElements = element.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    const firstFocusable = focusableElements[0] as HTMLElement;
    const lastFocusable = focusableElements[focusableElements.length - 1] as HTMLElement;
    
    const handleTabKey = (e: KeyboardEvent) => {
      if (e.key !== 'Tab') return;
      
      if (e.shiftKey && document.activeElement === firstFocusable) {
        e.preventDefault();
        lastFocusable.focus();
      } else if (!e.shiftKey && document.activeElement === lastFocusable) {
        e.preventDefault();
        firstFocusable.focus();
      }
    };
    
    element.addEventListener('keydown', handleTabKey);
    firstFocusable.focus();
    
    return () => element.removeEventListener('keydown', handleTabKey);
  },
  
  // Return focus to trigger element
  returnFocus: (triggerElement: HTMLElement) => {
    triggerElement?.focus();
  },
  
  // Skip to main content
  skipToMain: () => {
    const main = document.querySelector('main');
    main?.setAttribute('tabindex', '-1');
    main?.focus();
    main?.removeAttribute('tabindex');
  }
};

// Keyboard shortcuts
const keyboardShortcuts = {
  '/': () => {
    // Focus search input
    document.querySelector<HTMLInputElement>('input[type="search"]')?.focus();
  },
  
  '?': () => {
    // Show keyboard shortcuts help
    openModal('keyboard-shortcuts-help');
  },
  
  'g h': () => {
    // Go to home
    navigate('/');
  },
  
  'g d': () => {
    // Go to dashboard
    navigate('/dashboard');
  },
  
  'Escape': () => {
    // Close modals, clear filters, etc.
    closeAllModals();
  }
};
```

---

## Conclusion

This design specification provides comprehensive guidance for implementing the Chanuka platform UI. The architecture balances complexity with usability, performance with features, and innovation with accessibility. By following these specifications, development teams can build a civic engagement platform that truly serves democratic participation while maintaining technical excellence