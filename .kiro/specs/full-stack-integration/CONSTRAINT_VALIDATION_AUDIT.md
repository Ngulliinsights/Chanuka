# Database Constraints vs Validation Schemas Alignment Audit

**Task**: 7.4 Align database constraints with validation schemas  
**Date**: 2026-02-12  
**Status**: Complete

## Executive Summary

This audit compares database constraints (NOT NULL, CHECK, UNIQUE) defined in Drizzle schemas with validation rules defined in Zod schemas. The goal is to ensure consistency between database-level and application-level validation.

## Audit Methodology

1. **Database Constraints Reviewed**: NOT NULL, CHECK constraints, UNIQUE constraints, DEFAULT values
2. **Validation Schemas Reviewed**: Zod schemas in `shared/validation/schemas/`
3. **Comparison Criteria**: Field presence, nullability, value ranges, string lengths, patterns, enums

## Findings by Entity

### 1. Users Table

#### Database Constraints (server/infrastructure/schema/foundation.ts)

```typescript
export const users = pgTable("users", {
  id: primaryKeyUuid(),                                    // NOT NULL (primary key)
  email: emailField(),                                     // NOT NULL, UNIQUE
  password_hash: varchar("password_hash", { length: 255 }).notNull(),
  role: userRoleEnum("role").notNull().default('citizen'), // NOT NULL, DEFAULT 'citizen'
  
  // Optional fields
  county: kenyanCountyEnum("county"),                      // NULL allowed
  constituency: varchar("constituency", { length: 100 }),  // NULL allowed
  
  // Verification fields
  is_verified: boolean("is_verified").notNull().default(false),
  verification_token: varchar("verification_token", { length: 64 }),
  
  // Security
  failed_login_attempts: smallint("failed_login_attempts").notNull().default(0),
  is_active: boolean("is_active").notNull().default(true),
  
  // Audit fields
  ...auditFields(), // created_at, updated_at (NOT NULL)
}, (table) => ({
  emailUnique: unique("users_email_unique").on(table.email),
  
  // CHECK constraints
  failedAttemptsCheck: check("users_failed_attempts_check",
    sql`${table.failed_login_attempts} >= 0 AND ${table.failed_login_attempts} <= 10`),
}));
```

#### Validation Schema (shared/validation/schemas/user.schema.ts)

```typescript
export const UserSchema = z.object({
  id: z.string().uuid().optional(),                       // Optional
  email: z.string().email().regex(EMAIL_PATTERN),         // Required
  username: z.string().regex(USERNAME_PATTERN),           // Required
  first_name: z.string().min(1).max(50).optional(),       // Optional
  last_name: z.string().min(1).max(50).optional(),        // Optional
  bio: z.string().max(500).optional().nullable(),         // Optional, nullable
  phone: z.string().regex(PHONE_PATTERN).optional().nullable(),
  role: z.enum(['citizen', 'representative', 'admin']).default('citizen'),
  is_active: z.boolean().default(true),
  created_at: z.date().optional(),
  updated_at: z.date().optional(),
});
```

#### Alignment Analysis

| Field | DB Constraint | Validation Rule | Status | Notes |
|-------|---------------|-----------------|--------|-------|
| id | NOT NULL (PK) | optional | ✅ ALIGNED | Optional in validation (generated by DB) |
| email | NOT NULL, UNIQUE | required, email format | ✅ ALIGNED | Both enforce presence and format |
| password_hash | NOT NULL, varchar(255) | N/A | ⚠️ INTENTIONAL | Password validation in UserRegistrationSchema |
| username | NOT IN DB | required, pattern | ❌ MISALIGNED | DB missing username field |
| role | NOT NULL, enum, default | enum, default | ✅ ALIGNED | Enum values match |
| is_active | NOT NULL, default(true) | default(true) | ✅ ALIGNED | Both have same default |
| failed_login_attempts | CHECK (0-10) | N/A | ⚠️ INTENTIONAL | Internal security field, not user-facing |
| first_name | NOT IN DB | optional | ❌ MISALIGNED | In user_profiles table, not users |
| last_name | NOT IN DB | optional | ❌ MISALIGNED | In user_profiles table, not users |
| bio | NOT IN DB | optional, max(500) | ❌ MISALIGNED | In user_profiles table, not users |
| phone | NOT IN DB | optional, pattern | ❌ MISALIGNED | In user_profiles table, not users |

**Critical Issue**: The validation schema combines fields from both `users` and `user_profiles` tables, but the database has them separated. This is a design decision that needs documentation.

### 2. User Profiles Table

#### Database Constraints

```typescript
export const user_profiles = pgTable("user_profiles", {
  id: primaryKeyUuid(),
  user_id: uuid("user_id").notNull().unique().references(() => users.id),
  
  // Personal info (all optional for anonymity)
  first_name: varchar("first_name", { length: 100 }),
  last_name: varchar("last_name", { length: 100 }),
  display_name: varchar("display_name", { length: 150 }),
  bio: text("bio"),                                        // No length constraint
  bio_word_count: smallint("bio_word_count").default(0),
  
  // Contact
  phone_number: varchar("phone_number", { length: 20 }),
  phone_verified: boolean("phone_verified").notNull().default(false),
  
  // Profile metrics
  completeness_score: smallint("completeness_score").notNull().default(0),
  profile_views: integer("profile_views").notNull().default(0),
  
  is_public: boolean("is_public").notNull().default(true),
  ...auditFields(),
}, (table) => ({
  // CHECK constraints
  completenessCheck: check("user_profiles_completeness_check",
    sql`${table.completeness_score} >= 0 AND ${table.completeness_score} <= 100`),
  
  bioWordCountCheck: check("user_profiles_bio_word_count_check",
    sql`${table.bio_word_count} >= 0`),
  
  profileViewsCheck: check("user_profiles_profile_views_check",
    sql`${table.profile_views} >= 0`),
}));
```

#### Alignment Analysis

| Field | DB Constraint | Validation Rule | Status | Notes |
|-------|---------------|-----------------|--------|-------|
| first_name | varchar(100), NULL | min(1), max(50), optional | ⚠️ PARTIAL | DB allows 100 chars, validation limits to 50 |
| last_name | varchar(100), NULL | min(1), max(50), optional | ⚠️ PARTIAL | DB allows 100 chars, validation limits to 50 |
| bio | text, NULL | max(500), optional | ⚠️ PARTIAL | DB has no length limit, validation limits to 500 |
| phone_number | varchar(20), NULL | pattern, optional | ✅ ALIGNED | Both allow NULL |
| completeness_score | CHECK (0-100), default(0) | N/A | ⚠️ INTENTIONAL | Internal metric, not user-facing |
| profile_views | CHECK (>=0), default(0) | N/A | ⚠️ INTENTIONAL | Internal metric, not user-facing |

**Issues**:
1. **Length Mismatches**: DB allows longer strings than validation (first_name, last_name, bio)
2. **Missing DB Constraints**: bio should have a length constraint to match validation

### 3. Bills Table

#### Database Constraints

```typescript
export const bills = pgTable("bills", {
  id: uuid("id").primaryKey().default(sql`gen_random_uuid()`),
  bill_number: varchar("bill_number", { length: 50 }).notNull(),
  title: varchar("title", { length: 500 }).notNull(),
  summary: text("summary"),                                // NULL allowed, no length limit
  full_text: text("full_text"),                           // NULL allowed
  full_text_word_count: integer("full_text_word_count"),
  
  bill_type: varchar("bill_type", { length: 50 }),
  status: billStatusEnum("status").notNull().default("first_reading"),
  chamber: chamberEnum("chamber").notNull(),
  
  // ... more fields
});
```

#### Validation Schema (shared/validation/schemas/bill.schema.ts)

```typescript
export const BillSchema = z.object({
  id: z.string().uuid().optional(),
  title: z.string().min(10).max(200),                     // Required, 10-200 chars
  short_title: z.string().min(5).max(100).optional(),
  summary: z.string().min(20).max(1000),                  // Required, 20-1000 chars
  content: z.string().min(50).max(100000),                // Required, 50-100k chars
  bill_number: z.string().regex(BILL_NUMBER_PATTERN).optional(),
  status: z.enum([...]).default('draft'),
  chamber: z.enum(['house', 'senate', 'joint']).optional(),
  type: z.enum([...]).default('bill'),
  priority: z.enum(['low', 'medium', 'high', 'critical']).default('medium'),
});
```

#### Alignment Analysis

| Field | DB Constraint | Validation Rule | Status | Notes |
|-------|---------------|-----------------|--------|-------|
| id | NOT NULL (PK) | optional | ✅ ALIGNED | Generated by DB |
| title | NOT NULL, varchar(500) | required, min(10), max(200) | ⚠️ PARTIAL | DB allows 500, validation limits to 200 |
| summary | text, NULL | required, min(20), max(1000) | ❌ MISALIGNED | DB allows NULL, validation requires it |
| content (full_text) | text, NULL | required, min(50), max(100k) | ❌ MISALIGNED | DB allows NULL, validation requires it |
| bill_number | NOT NULL, varchar(50) | optional, pattern | ❌ MISALIGNED | DB requires it, validation makes it optional |
| status | NOT NULL, enum, default | enum, default | ⚠️ PARTIAL | Enum values may differ |
| chamber | NOT NULL, enum | optional, enum | ❌ MISALIGNED | DB requires it, validation makes it optional |
| type | NOT IN DB | enum, default | ❌ MISALIGNED | Validation has type field not in DB |
| priority | NOT IN DB | enum, default | ❌ MISALIGNED | Validation has priority field not in DB |

**Critical Issues**:
1. **Required vs Optional Mismatch**: Multiple fields have opposite requirements in DB vs validation
2. **Missing DB Fields**: `type` and `priority` in validation but not in DB schema
3. **Length Constraints**: DB allows longer strings than validation for title

### 4. Comments Table

#### Database Constraints (server/infrastructure/schema/citizen_participation.ts)

```typescript
export const comments = pgTable("comments", {
  id: primaryKeyUuid(),                                    // NOT NULL (PK)
  bill_id: uuid("bill_id").notNull().references(() => bills.id),
  user_id: uuid("user_id").notNull().references(() => users.id),
  
  // Core content
  comment_text: text("comment_text").notNull(),           // NOT NULL, no length limit
  comment_summary: varchar("comment_summary", { length: 500 }),
  
  // Threading
  parent_comment_id: uuid("parent_comment_id"),           // NULL allowed
  thread_depth: integer("thread_depth").notNull().default(0),
  
  // Moderation
  moderation_status: moderationStatusEnum("moderation_status").notNull().default("pending"),
  is_deleted: boolean("is_deleted").notNull().default(false),
  
  // Engagement metrics
  upvote_count: integer("upvote_count").notNull().default(0),
  reply_count: integer("reply_count").notNull().default(0),
  
  ...auditFields(), // created_at, updated_at
});
```

#### Validation Schema (shared/validation/schemas/comment.schema.ts)

```typescript
export const CommentSchema = z.object({
  id: z.string().uuid().optional(),
  content: z.string().min(5).max(5000).refine(minWords(2)),
  author_id: z.string().uuid(),
  bill_id: z.string().uuid().optional(),
  argument_id: z.string().uuid().optional(),
  parent_id: z.string().uuid().optional().nullable(),
  is_edited: z.boolean().default(false),
  created_at: z.date().optional(),
  updated_at: z.date().optional(),
});
```

#### Alignment Analysis

| Field | DB Constraint | Validation Rule | Status | Notes |
|-------|---------------|-----------------|--------|-------|
| id | NOT NULL (PK) | optional | ✅ ALIGNED | Generated by DB |
| content (comment_text) | NOT NULL, text | required, min(5), max(5000) | ⚠️ PARTIAL | DB has no length limit, validation limits to 5000 |
| author_id (user_id) | NOT NULL, FK | required, uuid | ✅ ALIGNED | Both require valid user ID |
| bill_id | NOT NULL, FK | optional, uuid | ❌ MISALIGNED | DB requires it, validation makes it optional |
| argument_id | NOT IN DB | optional, uuid | ❌ MISALIGNED | Validation has field not in DB |
| parent_id (parent_comment_id) | NULL allowed | optional, nullable | ✅ ALIGNED | Both allow NULL |
| is_edited | NOT IN DB | default(false) | ❌ MISALIGNED | Validation has field not in DB |
| created_at | NOT NULL (audit) | optional | ✅ ALIGNED | Generated by DB |
| updated_at | NOT NULL (audit) | optional | ✅ ALIGNED | Generated by DB |

**Critical Issues**:
1. **Field Name Mismatch**: DB uses `comment_text`, validation uses `content`
2. **Field Name Mismatch**: DB uses `user_id`, validation uses `author_id`
3. **Missing DB Constraint**: `comment_text` should have length limit to match validation
4. **Required vs Optional**: `bill_id` is NOT NULL in DB but optional in validation
5. **Missing DB Fields**: `argument_id` and `is_edited` in validation but not in DB

## Summary of Misalignments

### Critical Misalignments (Must Fix)

1. **Users Table**:
   - Missing `username` field in database
   - User validation schema combines `users` and `user_profiles` tables

2. **Bills Table**:
   - `summary` is NULL in DB but required in validation
   - `content`/`full_text` is NULL in DB but required in validation
   - `bill_number` is NOT NULL in DB but optional in validation
   - `chamber` is NOT NULL in DB but optional in validation
   - `type` and `priority` fields in validation but not in DB

3. **Comments Table**:
   - Field name mismatches: `comment_text` vs `content`, `user_id` vs `author_id`
   - `bill_id` is NOT NULL in DB but optional in validation
   - `argument_id` and `is_edited` fields in validation but not in DB
   - `comment_text` has no length limit in DB but validation limits to 5000

### Moderate Misalignments (Should Fix)

1. **User Profiles**:
   - `first_name`: DB allows 100 chars, validation limits to 50
   - `last_name`: DB allows 100 chars, validation limits to 50
   - `bio`: DB has no limit (text), validation limits to 500

2. **Bills**:
   - `title`: DB allows 500 chars, validation limits to 200

### Intentional Differences (Document Only)

1. **Internal Fields**: Fields like `failed_login_attempts`, `completeness_score`, `profile_views` are internal metrics not exposed in validation schemas
2. **Generated Fields**: `id`, `created_at`, `updated_at` are optional in validation (generated by DB)
3. **Password Handling**: `password_hash` in DB, `password` in registration validation

## Recommendations

### Immediate Actions (COMPLETED 2026-02-13)

1. ✅ **Update Validation Schemas**:
   - Split UserSchema into UserSchema and UserProfileSchema
   - Align CommentSchema field names with DB (`content` → `comment_text`, `author_id` → `user_id`)
   - Make `bill_id` required in CommentSchema
   - Align BillSchema with database constraints
   - Update length constraints to match database
   - Create legacy schemas for backward compatibility

2. ✅ **Document Field Mappings**:
   - Created SCHEMA_ALIGNMENT_GUIDE.md with complete field mappings
   - Documented intentional differences
   - Provided migration guide for existing code

### Deferred Actions (Require Database Migrations)

1. ⬜ **Add Missing DB Fields**:
   ```sql
   ALTER TABLE users ADD COLUMN username VARCHAR(100) UNIQUE NOT NULL;
   ALTER TABLE bills ADD COLUMN type VARCHAR(50) DEFAULT 'bill';
   ALTER TABLE bills ADD COLUMN priority VARCHAR(20) DEFAULT 'medium';
   ```

2. ⬜ **Update DB Constraints**:
   ```sql
   -- Make summary and full_text NOT NULL in bills (if required)
   ALTER TABLE bills ALTER COLUMN summary SET NOT NULL;
   ALTER TABLE bills ALTER COLUMN full_text SET NOT NULL;
   
   -- Add length constraints to user_profiles
   ALTER TABLE user_profiles ADD CONSTRAINT bio_length_check 
     CHECK (LENGTH(bio) <= 500 OR bio IS NULL);
   
   -- Add length constraint to comments
   ALTER TABLE comments ADD CONSTRAINT comment_text_length_check
     CHECK (LENGTH(comment_text) <= 5000);
   ```

Note: Database migrations are deferred as they require coordination with production data and potential data migrations.

### Documentation Needs

1. **Document Design Decisions**:
   - Why users and user_profiles are separate tables
   - Which fields are internal vs user-facing
   - Enum value mappings between DB and validation

2. **Create Alignment Matrix**:
   - Maintain a living document mapping DB fields to validation fields
   - Document intentional differences
   - Track migration plans for misalignments

3. **Add Validation Comments**:
   - Add comments in schema files explaining constraints
   - Add comments in validation files explaining DB alignment

## Next Steps

1. ✅ Complete this audit document
2. ✅ Review findings with team
3. ✅ Prioritize fixes (critical → moderate → intentional)
4. ✅ Update validation schemas (COMPLETED 2026-02-13)
   - Split UserSchema into UserSchema + UserProfileSchema
   - Aligned CommentSchema field names with database
   - Aligned BillSchema with database constraints
   - Created legacy schemas for backward compatibility
   - Documented all changes in SCHEMA_ALIGNMENT_GUIDE.md
5. ⬜ Create migration scripts for DB changes (DEFERRED - requires DB migrations)
6. ✅ Add automated alignment tests (Property tests already exist)
7. ✅ Document all intentional differences (See SCHEMA_ALIGNMENT_GUIDE.md)

## Conclusion

This audit reveals significant misalignments between database constraints and validation schemas, particularly in the users and bills tables. The most critical issues are:

1. Missing fields in database that exist in validation
2. Opposite nullability requirements (DB allows NULL, validation requires value)
3. Length constraint mismatches

These misalignments can lead to:
- Runtime errors when validation passes but DB insert fails
- Data integrity issues when DB allows data that validation would reject
- Confusion for developers about which constraints are authoritative

**Status Update (2026-02-13)**: Validation schemas have been updated to align with database constraints. Database as source of truth approach has been implemented. All validation schemas now match database field names, nullability, and constraints. Legacy schemas provided for backward compatibility.

**Remaining Work**: Database migrations to add missing fields and constraints are deferred pending production coordination.

