/**
 * Client-Side Vulnerability Scanner
 * Provides security monitoring and vulnerability detection
 */

export interface SecurityThreat {
  type: 'xss' | 'injection' | 'traversal' | 'csrf' | 'clickjacking' | 'mixed_content';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  location?: string;
  recommendation: string;
  timestamp: number;
}

export interface SecurityScanResult {
  threats: SecurityThreat[];
  score: number; // 0-100, higher is better
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
}

export class VulnerabilityScanner {
  private static instance: VulnerabilityScanner;
  private scanHistory: SecurityScanResult[] = [];
  private readonly MAX_HISTORY = 50;

  private constructor() {}

  public static getInstance(): VulnerabilityScanner {
    if (!VulnerabilityScanner.instance) {
      VulnerabilityScanner.instance = new VulnerabilityScanner();
    }
    return VulnerabilityScanner.instance;
  }

  /**
   * Perform comprehensive security scan
   */
  public performScan(): SecurityScanResult {
    const threats: SecurityThreat[] = [];

    // Check for XSS vulnerabilities
    threats.push(...this.scanForXSS());

    // Check for CSRF vulnerabilities
    threats.push(...this.scanForCSRF());

    // Check for clickjacking vulnerabilities
    threats.push(...this.scanForClickjacking());

    // Check for mixed content
    threats.push(...this.scanForMixedContent());

    // Check for insecure storage
    threats.push(...this.scanForInsecureStorage());

    // Check for DOM-based vulnerabilities
    threats.push(...this.scanForDOMVulnerabilities());

    // Calculate security score
    const score = this.calculateSecurityScore(threats);

    // Create summary
    const summary = {
      critical: threats.filter(t => t.severity === 'critical').length,
      high: threats.filter(t => t.severity === 'high').length,
      medium: threats.filter(t => t.severity === 'medium').length,
      low: threats.filter(t => t.severity === 'low').length
    };

    const result: SecurityScanResult = {
      threats,
      score,
      summary
    };

    // Store in history
    this.scanHistory.unshift(result);
    if (this.scanHistory.length > this.MAX_HISTORY) {
      this.scanHistory.pop();
    }

    return result;
  }

  /**
   * Scan for XSS vulnerabilities
   */
  private scanForXSS(): SecurityThreat[] {
    const threats: SecurityThreat[] = [];

    // Check for inline scripts
    const inlineScripts = document.querySelectorAll('script:not([src])');
    if (inlineScripts.length > 0) {
      threats.push({
        type: 'xss',
        severity: 'medium',
        description: `Found ${inlineScripts.length} inline script(s)`,
        location: 'DOM',
        recommendation: 'Use external scripts with CSP nonce or move to external files',
        timestamp: Date.now()
      });
    }

    // Check for dangerous innerHTML usage
    const elements = document.querySelectorAll('*');
    elements.forEach((element, index) => {
      const innerHTML = element.innerHTML;
      if (innerHTML.includes('<script') || innerHTML.includes('javascript:')) {
        threats.push({
          type: 'xss',
          severity: 'high',
          description: 'Potentially dangerous innerHTML content detected',
          location: `Element ${index}: ${element.tagName}`,
          recommendation: 'Sanitize HTML content before insertion',
          timestamp: Date.now()
        });
      }
    });

    // Check for eval usage (if possible to detect)
    if (typeof window !== 'undefined' && (window as any).eval.toString().includes('[native code]')) {
      // eval hasn't been overridden, which is good
    } else {
      threats.push({
        type: 'xss',
        severity: 'critical',
        description: 'eval function may have been overridden',
        location: 'Global scope',
        recommendation: 'Avoid using eval and ensure it hasn\'t been tampered with',
        timestamp: Date.now()
      });
    }

    return threats;
  }

  /**
   * Scan for CSRF vulnerabilities
   */
  private scanForCSRF(): SecurityThreat[] {
    const threats: SecurityThreat[] = [];

    // Check for forms without CSRF protection
    const forms = document.querySelectorAll('form');
    forms.forEach((form, index) => {
      const hasCSRFToken = form.querySelector('input[name="_csrf"]') || 
                          form.querySelector('input[name="csrf_token"]');
      
      if (!hasCSRFToken && form.method.toLowerCase() !== 'get') {
        threats.push({
          type: 'csrf',
          severity: 'high',
          description: `Form without CSRF protection detected`,
          location: `Form ${index}`,
          recommendation: 'Add CSRF token to all state-changing forms',
          timestamp: Date.now()
        });
      }
    });

    return threats;
  }

  /**
   * Scan for clickjacking vulnerabilities
   */
  private scanForClickjacking(): SecurityThreat[] {
    const threats: SecurityThreat[] = [];

    // Check if page can be framed
    try {
      if (window.self !== window.top) {
        threats.push({
          type: 'clickjacking',
          severity: 'medium',
          description: 'Page is being displayed in a frame',
          location: 'Window context',
          recommendation: 'Implement X-Frame-Options or CSP frame-ancestors',
          timestamp: Date.now()
        });
      }
    } catch (e) {
      // This is actually good - it means frame busting is working
    }

    // Check for missing frame busting
    const hasFrameBusting = document.querySelector('script')?.textContent?.includes('top.location') ||
                           document.querySelector('script')?.textContent?.includes('frameElement');
    
    if (!hasFrameBusting) {
      threats.push({
        type: 'clickjacking',
        severity: 'low',
        description: 'No client-side frame busting detected',
        location: 'Document head',
        recommendation: 'Consider adding frame busting script as defense in depth',
        timestamp: Date.now()
      });
    }

    return threats;
  }

  /**
   * Scan for mixed content issues
   */
  private scanForMixedContent(): SecurityThreat[] {
    const threats: SecurityThreat[] = [];

    if (location.protocol === 'https:') {
      // Check for HTTP resources on HTTPS page
      const httpResources = document.querySelectorAll(
        'img[src^="http:"], script[src^="http:"], link[href^="http:"], iframe[src^="http:"]'
      );

      if (httpResources.length > 0) {
        threats.push({
          type: 'mixed_content',
          severity: 'medium',
          description: `Found ${httpResources.length} HTTP resource(s) on HTTPS page`,
          location: 'Various elements',
          recommendation: 'Update all resources to use HTTPS',
          timestamp: Date.now()
        });
      }
    }

    return threats;
  }

  /**
   * Scan for insecure storage practices
   */
  private scanForInsecureStorage(): SecurityThreat[] {
    const threats: SecurityThreat[] = [];

    // Check localStorage for sensitive data patterns
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key || '');
        
        if (key && value) {
          // Check for potential passwords or tokens
          if (key.toLowerCase().includes('password') || 
              key.toLowerCase().includes('secret') ||
              value.length > 100) { // Potential JWT or long token
            threats.push({
              type: 'injection',
              severity: 'medium',
              description: `Potentially sensitive data in localStorage: ${key}`,
              location: 'localStorage',
              recommendation: 'Use secure storage methods for sensitive data',
              timestamp: Date.now()
            });
          }
        }
      }
    } catch (e) {
      // localStorage might not be available
    }

    return threats;
  }

  /**
   * Scan for DOM-based vulnerabilities
   */
  private scanForDOMVulnerabilities(): SecurityThreat[] {
    const threats: SecurityThreat[] = [];

    // Check for dangerous DOM manipulation
    const dangerousElements = document.querySelectorAll('[onclick], [onload], [onerror]');
    if (dangerousElements.length > 0) {
      threats.push({
        type: 'xss',
        severity: 'medium',
        description: `Found ${dangerousElements.length} element(s) with inline event handlers`,
        location: 'DOM elements',
        recommendation: 'Use addEventListener instead of inline event handlers',
        timestamp: Date.now()
      });
    }

    // Check for document.write usage
    const scripts = document.querySelectorAll('script');
    scripts.forEach((script, index) => {
      if (script.textContent?.includes('document.write')) {
        threats.push({
          type: 'xss',
          severity: 'low',
          description: 'document.write usage detected',
          location: `Script ${index}`,
          recommendation: 'Use modern DOM manipulation methods instead of document.write',
          timestamp: Date.now()
        });
      }
    });

    return threats;
  }

  /**
   * Calculate security score based on threats
   */
  private calculateSecurityScore(threats: SecurityThreat[]): number {
    let score = 100;

    threats.forEach(threat => {
      switch (threat.severity) {
        case 'critical':
          score -= 25;
          break;
        case 'high':
          score -= 15;
          break;
        case 'medium':
          score -= 8;
          break;
        case 'low':
          score -= 3;
          break;
      }
    });

    return Math.max(0, score);
  }

  /**
   * Get scan history
   */
  public getScanHistory(): SecurityScanResult[] {
    return [...this.scanHistory];
  }

  /**
   * Get latest scan result
   */
  public getLatestScan(): SecurityScanResult | null {
    return this.scanHistory[0] || null;
  }

  /**
   * Clear scan history
   */
  public clearHistory(): void {
    this.scanHistory = [];
  }

  /**
   * Monitor for real-time threats
   */
  public startMonitoring(callback: (threat: SecurityThreat) => void): () => void {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node as Element;
              
              // Check for dangerous additions
              if (element.tagName === 'SCRIPT' && !element.getAttribute('src')) {
                callback({
                  type: 'xss',
                  severity: 'high',
                  description: 'Inline script dynamically added to DOM',
                  location: `${element.tagName}`,
                  recommendation: 'Investigate the source of this script injection',
                  timestamp: Date.now()
                });
              }
            }
          });
        }
      });
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });

    return () => observer.disconnect();
  }
}

// Export singleton instance
export const vulnerabilityScanner = VulnerabilityScanner.getInstance();