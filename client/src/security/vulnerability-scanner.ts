/**
 * Client-Side Vulnerability Scanner
 * Detects security vulnerabilities and configuration issues
 */

import { SecurityEvent, VulnerabilityReport, VulnerabilityType } from '@client/types';

import { logger } from '@client/utils/logger';

export interface VulnerabilityScannerConfig {
  enabled: boolean;
  scanInterval: number;
  reportEndpoint: string;
  enableDependencyScanning?: boolean;
  enableConfigurationScanning?: boolean;
  enableRuntimeScanning?: boolean;
}

interface VulnerabilityCheck {
  id: string;
  name: string;
  type: VulnerabilityType;
  severity: 'low' | 'medium' | 'high' | 'critical';
  // Changed to support async checks
  check: () => Promise<VulnerabilityResult>;
}

interface VulnerabilityResult {
  vulnerable: boolean;
  description: string;
  details: Record<string, any>;
  recommendations: string[];
  cveId?: string;
}

export class VulnerabilityScanner {
  private config: VulnerabilityScannerConfig;
  private scanTimer: NodeJS.Timeout | null = null;
  private vulnerabilities: VulnerabilityReport[] = [];
  private checks: VulnerabilityCheck[] = [];
  private lastScanTime: Date | null = null;
  private lastScanResult: { score: number, threats: VulnerabilityReport[] } | null = null;

  constructor(config: VulnerabilityScannerConfig) {
    this.config = {
      enableDependencyScanning: true,
      enableConfigurationScanning: true,
      enableRuntimeScanning: true,
      ...config
    };
    
    this.initializeChecks();
  }

  async initialize(): Promise<void> {
    if (!this.config.enabled) {
      logger.info('Vulnerability Scanner disabled');
      return;
    }

    try {
      // Run initial scan
      await this.runScan();
      
      // Set up periodic scanning
      this.setupPeriodicScanning();

      logger.info('Vulnerability Scanner initialized successfully', {
        scanInterval: this.config.scanInterval,
        checksCount: this.checks.length
      });
    } catch (error) {
      // Properly typed error for logger context
      logger.error('Failed to initialize Vulnerability Scanner', {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      throw error;
    }
  }

  private initializeChecks(): void {
    this.checks = [
      // Configuration vulnerabilities
      {
        id: 'csp-missing',
        name: 'Missing Content Security Policy',
        type: 'security_misconfiguration',
        severity: 'high',
        check: async () => this.checkCSP()
      },
      {
        id: 'https-missing',
        name: 'Insecure Protocol Usage',
        type: 'insecure_protocol',
        severity: 'high',
        check: async () => this.checkHTTPS()
      },
      {
        id: 'security-headers-missing',
        name: 'Missing Security Headers',
        type: 'security_misconfiguration',
        severity: 'medium',
        check: async () => this.checkSecurityHeaders()
      },
      
      // Runtime vulnerabilities
      {
        id: 'xss-protection',
        name: 'XSS Protection Disabled',
        type: 'configuration_issue',
        severity: 'medium',
        check: async () => this.checkXSSProtection()
      },
      {
        id: 'mixed-content',
        name: 'Mixed Content Issues',
        type: 'insecure_protocol',
        severity: 'medium',
        check: async () => this.checkMixedContent()
      },
      {
        id: 'insecure-cookies',
        name: 'Insecure Cookie Configuration',
        type: 'configuration_issue',
        severity: 'medium',
        check: async () => this.checkCookieSecurity()
      },
      
      // Dependency vulnerabilities
      {
        id: 'outdated-dependencies',
        name: 'Outdated Dependencies',
        type: 'outdated_dependency',
        severity: 'low',
        check: async () => this.checkDependencies()
      },
      
      // Code vulnerabilities
      {
        id: 'global-variables',
        name: 'Exposed Global Variables',
        type: 'code_vulnerability',
        severity: 'low',
        check: async () => this.checkGlobalVariables()
      },
      {
        id: 'console-logs',
        name: 'Debug Information Exposure',
        type: 'code_vulnerability',
        severity: 'low',
        check: async () => this.checkConsoleExposure()
      },
      {
        id: 'weak-randomness',
        name: 'Weak Random Number Generation',
        type: 'code_vulnerability',
        severity: 'medium',
        check: async () => this.checkRandomness()
      }
    ];
  }

  // Changed to async to properly handle async checks
  private async runScan(): Promise<VulnerabilityReport[]> {
    logger.info('Starting vulnerability scan', {
      component: 'VulnerabilityScanner',
      checksCount: this.checks.length
    });

    const results: VulnerabilityReport[] = [];

    // Process all checks with proper async handling
    for (const check of this.checks) {
      try {
        // Now properly awaiting the async check
        const result = await check.check();

        if (result.vulnerable) {
          const report: VulnerabilityReport = {
            id: `vuln-${Date.now()}-${check.id}`,
            timestamp: new Date(),
            type: check.type,
            severity: check.severity,
            description: result.description,
            affectedComponents: [check.name],
            recommendations: result.recommendations,
            cveId: result.cveId,
            fixed: false
          };

          results.push(report);
          this.vulnerabilities.push(report);
        }
      } catch (error) {
        logger.error(`Vulnerability check failed: ${check.id}`, {
          error: error instanceof Error ? error.message : String(error),
          checkId: check.id
        });
      }
    }

    this.lastScanTime = new Date();
    
    if (results.length > 0) {
      // In development mode, use debug level for expected vulnerabilities
      if (process.env.NODE_ENV === 'development') {
        logger.debug(`Vulnerability scan completed: ${results.length} vulnerabilities found (development mode)`, {
          component: 'VulnerabilityScanner',
          vulnerabilities: results.map(v => ({
            type: v.type,
            severity: v.severity,
            description: v.description
          }))
        });
      } else {
        logger.warn(`Vulnerability scan completed: ${results.length} vulnerabilities found`, {
          component: 'VulnerabilityScanner',
          vulnerabilities: results.map(v => ({
            type: v.type,
            severity: v.severity,
            description: v.description
          }))
        });
      }
      
      // Report vulnerabilities (now properly awaited)
      await this.reportVulnerabilities(results);
    } else {
      logger.info('Vulnerability scan completed: No vulnerabilities found');
    }

    return results;
  }

  // Vulnerability check implementations
  private checkCSP(): VulnerabilityResult {
    const cspMeta = document.querySelector('meta[http-equiv*="Content-Security-Policy"]');
    const cspHeader = (window as any).__CSP_POLICY__;

    const hasCSP = cspMeta || cspHeader;

    return {
      vulnerable: !hasCSP,
      description: hasCSP ? 'Content Security Policy is configured' : 'No Content Security Policy found',
      details: {
        metaTag: !!cspMeta,
        headerPolicy: !!cspHeader,
        policy: cspMeta?.getAttribute('content') || cspHeader
      },
      recommendations: hasCSP ? [] : [
        'Implement Content Security Policy to prevent XSS attacks',
        'Use nonce-based script execution for better security',
        'Regularly review and update CSP directives'
      ]
    };
  }

  private checkHTTPS(): VulnerabilityResult {
    const isHTTPS = window.location.protocol === 'https:';
    const isLocalhost = window.location.hostname === 'localhost' ||
                        window.location.hostname === '127.0.0.1';

    const vulnerable = !isHTTPS && !isLocalhost;

    return {
      vulnerable,
      description: vulnerable ? 'Site is not using HTTPS' : 'Site is using secure HTTPS protocol',
      details: {
        protocol: window.location.protocol,
        hostname: window.location.hostname,
        isLocalhost
      },
      recommendations: vulnerable ? [
        'Enable HTTPS for all production environments',
        'Implement HTTP Strict Transport Security',
        'Redirect all HTTP traffic to HTTPS'
      ] : []
    };
  }

  private checkSecurityHeaders(): VulnerabilityResult {
    const requiredHeaders = [
      'X-Content-Type-Options',
      'X-Frame-Options',
      'X-XSS-Protection',
      'Referrer-Policy'
    ];
    
    const missingHeaders: string[] = [];
    
    for (const header of requiredHeaders) {
      const meta = document.querySelector(`meta[http-equiv="${header}"]`);
      if (!meta) {
        missingHeaders.push(header);
      }
    }
    
    const vulnerable = missingHeaders.length > 0;
    
    return {
      vulnerable,
      description: vulnerable 
        ? `Missing security headers: ${missingHeaders.join(', ')}`
        : 'All required security headers are present',
      details: {
        missingHeaders,
        totalRequired: requiredHeaders.length
      },
      recommendations: vulnerable ? [
        'Implement missing security headers',
        'Use X-Content-Type-Options: nosniff',
        'Use X-Frame-Options: DENY or SAMEORIGIN',
        'Configure appropriate Referrer-Policy'
      ] : []
    };
  }

  private checkXSSProtection(): VulnerabilityResult {
    const xssProtection = document.querySelector('meta[http-equiv="X-XSS-Protection"]');
    const content = xssProtection?.getAttribute('content');
    
    const vulnerable = !content || !content.includes('1');
    
    return {
      vulnerable,
      description: vulnerable 
        ? 'XSS Protection is disabled or not configured'
        : 'XSS Protection is enabled',
      details: {
        hasHeader: !!xssProtection,
        content: content || null
      },
      recommendations: vulnerable ? [
        'Enable XSS Protection with "1; mode=block"',
        'Implement proper input validation and output encoding'
      ] : []
    };
  }

  private checkMixedContent(): VulnerabilityResult {
    const isHTTPS = window.location.protocol === 'https:';
    if (!isHTTPS) {
      return {
        vulnerable: false,
        description: 'Mixed content check not applicable for HTTP sites',
        details: {},
        recommendations: []
      };
    }

    // Check for mixed content in various elements
    const httpResources: string[] = [];
    
    // Check images
    document.querySelectorAll('img[src^="http:"]').forEach(img => {
      httpResources.push(`Image: ${(img as HTMLImageElement).src}`);
    });
    
    // Check scripts
    document.querySelectorAll('script[src^="http:"]').forEach(script => {
      httpResources.push(`Script: ${(script as HTMLScriptElement).src}`);
    });
    
    // Check stylesheets
    document.querySelectorAll('link[href^="http:"]').forEach(link => {
      httpResources.push(`Stylesheet: ${(link as HTMLLinkElement).href}`);
    });
    
    const vulnerable = httpResources.length > 0;
    
    return {
      vulnerable,
      description: vulnerable 
        ? `Found ${httpResources.length} mixed content resources`
        : 'No mixed content detected',
      details: {
        httpResources,
        count: httpResources.length
      },
      recommendations: vulnerable ? [
        'Update all HTTP resources to use HTTPS',
        'Use protocol-relative URLs where appropriate',
        'Implement Content Security Policy with upgrade-insecure-requests'
      ] : []
    };
  }

  private checkCookieSecurity(): VulnerabilityResult {
    const cookies = document.cookie.split(';');
    const insecureCookies: string[] = [];
    
    // Note: We can't fully inspect cookie security attributes from JavaScript
    // This is a simplified check
    cookies.forEach(cookie => {
      const name = cookie.split('=')[0].trim();
      if (name && !name.startsWith('__Secure-') && !name.startsWith('__Host-')) {
        insecureCookies.push(name);
      }
    });
    
    const vulnerable = insecureCookies.length > 0 && window.location.protocol === 'https:';
    
    return {
      vulnerable,
      description: vulnerable 
        ? `Found ${insecureCookies.length} potentially insecure cookies`
        : 'Cookie security appears adequate',
      details: {
        insecureCookies,
        totalCookies: cookies.length,
        isHTTPS: window.location.protocol === 'https:'
      },
      recommendations: vulnerable ? [
        'Use Secure flag for all cookies over HTTPS',
        'Use SameSite attribute to prevent CSRF',
        'Use HttpOnly flag for session cookies',
        'Consider using __Secure- or __Host- prefixes'
      ] : []
    };
  }

  private checkDependencies(): VulnerabilityResult {
    // This is a simplified check - in a real implementation,
    // you'd check against a vulnerability database
    const buildTime = (window as any).__BUILD_TIME__;
    const isOld = buildTime && (Date.now() - new Date(buildTime).getTime()) > (30 * 24 * 60 * 60 * 1000); // 30 days
    
    return {
      vulnerable: !!isOld,
      description: isOld 
        ? 'Application build is more than 30 days old'
        : 'Application build is recent',
      details: {
        buildTime,
        daysSinceBuild: buildTime ? Math.floor((Date.now() - new Date(buildTime).getTime()) / (24 * 60 * 60 * 1000)) : null
      },
      recommendations: isOld ? [
        'Update dependencies regularly',
        'Monitor security advisories for used packages',
        'Implement automated dependency scanning in CI/CD'
      ] : []
    };
  }

  private checkGlobalVariables(): VulnerabilityResult {
    const sensitiveGlobals = [
      '__CSRF_TOKEN__',
      '__API_KEY__',
      '__SECRET__',
      '__PASSWORD__'
    ];
    
    const exposedGlobals: string[] = [];
    
    sensitiveGlobals.forEach(global => {
      if ((window as any)[global] !== undefined) {
        exposedGlobals.push(global);
      }
    });
    
    const vulnerable = exposedGlobals.length > 0;
    
    return {
      vulnerable,
      description: vulnerable 
        ? `Found ${exposedGlobals.length} exposed sensitive global variables`
        : 'No sensitive global variables detected',
      details: {
        exposedGlobals
      },
      recommendations: vulnerable ? [
        'Avoid exposing sensitive data in global variables',
        'Use secure storage mechanisms for sensitive data',
        'Implement proper data encapsulation'
      ] : []
    };
  }

  private checkConsoleExposure(): VulnerabilityResult {
    // Check if console methods are overridden (indicating debug mode)
    const originalConsole = (window as any).__originalConsole__;
    const hasDebugInfo = !!originalConsole || process.env.NODE_ENV === 'development';
    
    return {
      vulnerable: hasDebugInfo && window.location.protocol === 'https:',
      description: hasDebugInfo 
        ? 'Debug information may be exposed in production'
        : 'No debug information exposure detected',
      details: {
        hasOriginalConsole: !!originalConsole,
        nodeEnv: process.env.NODE_ENV,
        isProduction: window.location.protocol === 'https:'
      },
      recommendations: hasDebugInfo ? [
        'Remove debug code from production builds',
        'Use proper logging levels',
        'Implement secure logging practices'
      ] : []
    };
  }

  private checkRandomness(): VulnerabilityResult {
    // Check if crypto.getRandomValues is available and being used
    const hasCrypto = typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function';
    const hasMathRandom = Math.random.toString().includes('[native code]');
    
    // This is a simplified check - would need more sophisticated analysis in practice
    const vulnerable = !hasCrypto;
    
    return {
      vulnerable,
      description: vulnerable 
        ? 'Cryptographically secure random number generation not available'
        : 'Secure random number generation is available',
      details: {
        hasCrypto,
        hasMathRandom,
        cryptoAvailable: typeof crypto !== 'undefined'
      },
      recommendations: vulnerable ? [
        'Use crypto.getRandomValues() for security-sensitive random numbers',
        'Avoid Math.random() for cryptographic purposes',
        'Consider using a polyfill for older browsers'
      ] : []
    };
  }

  private setupPeriodicScanning(): void {
    this.scanTimer = setInterval(() => {
      // Properly handle the promise from async runScan
      this.runScan().catch((error: Error) => {
        logger.error('Periodic vulnerability scan failed', {
          error: error.message,
          stack: error.stack
        });
      });
    }, this.config.scanInterval);
  }

  private async reportVulnerabilities(vulnerabilities: VulnerabilityReport[]): Promise<void> {
    // Skip backend reporting in development mode or if endpoint is not available
    if (process.env.NODE_ENV === 'development') {
      logger.debug('Development mode: skipping vulnerability report to backend', {
        component: 'VulnerabilityScanner',
        vulnerabilityCount: vulnerabilities.length
      });
      return;
    }

    // Report to backend
    try {
      const response = await fetch(this.config.reportEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          timestamp: new Date().toISOString(),
          vulnerabilities,
          userAgent: navigator.userAgent,
          url: window.location.href
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
    } catch (error) {
      logger.debug('Failed to report vulnerabilities to backend (this is expected in development)', {
        error: error instanceof Error ? error.message : String(error),
        endpoint: this.config.reportEndpoint,
        component: 'VulnerabilityScanner'
      });
    }

    // Create security events
    vulnerabilities.forEach(vuln => {
      const securityEvent: Partial<SecurityEvent> = {
        type: 'vulnerability_detected',
        severity: vuln.severity,
        source: 'VulnerabilityScanner',
        details: vuln
      };

      const customEvent = new CustomEvent('security-event', {
        detail: securityEvent
      });
      document.dispatchEvent(customEvent);
    });
  }

  /**
   * Run manual scan
   */
  async scan(): Promise<{ score: number, threats: VulnerabilityReport[] }> {
    const threats = await this.runScan();
    
    // Calculate score based on threats
    let score = 100;
    threats.forEach(threat => {
      if (threat.severity === 'critical') score -= 30;
      else if (threat.severity === 'high') score -= 20;
      else if (threat.severity === 'medium') score -= 10;
      else if (threat.severity === 'low') score -= 5;
    });
    
    score = Math.max(0, score);
    this.lastScanResult = { score, threats };
    return { score, threats };
  }

  /**
   * Get all detected vulnerabilities
   */
  getVulnerabilities(): VulnerabilityReport[] {
    return [...this.vulnerabilities];
  }

  /**
   * Get vulnerabilities by severity
   */
  getVulnerabilitiesBySeverity(severity: 'low' | 'medium' | 'high' | 'critical'): VulnerabilityReport[] {
    return this.vulnerabilities.filter(v => v.severity === severity);
  }

  /**
   * Mark vulnerability as fixed
   */
  markFixed(vulnerabilityId: string): void {
    const vuln = this.vulnerabilities.find(v => v.id === vulnerabilityId);
    if (vuln) {
      vuln.fixed = true;
    }
  }

  /**
   * Get scan statistics
   */
  getStats(): {
    lastScanTime: Date | null;
    totalVulnerabilities: number;
    vulnerabilitiesBySeverity: Record<string, number>;
    fixedVulnerabilities: number;
  } {
    const vulnerabilitiesBySeverity = this.vulnerabilities.reduce((acc, vuln) => {
      acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return {
      lastScanTime: this.lastScanTime,
      totalVulnerabilities: this.vulnerabilities.length,
      vulnerabilitiesBySeverity,
      fixedVulnerabilities: this.vulnerabilities.filter(v => v.fixed).length
    };
  }

  /**
   * Cleanup resources
   */
  async shutdown(): Promise<void> {
    if (this.scanTimer) {
      clearInterval(this.scanTimer);
      this.scanTimer = null;
    }
  }

  /**
   * Start monitoring for threats
   */
  startMonitoring(callback: (threat: SecurityThreat) => void): () => void {
    const interval = setInterval(async () => {
      const results = await this.scan();
      results.threats.forEach(threat => callback(threat));
    }, this.config.scanInterval);
    
    return () => clearInterval(interval);
  }

  /**
   * Get latest scan result
   */
  getLatestScan(): { score: number, threats: VulnerabilityReport[] } | null {
    return this.lastScanResult;
  }
}

// Export singleton instance
export const vulnerabilityScanner = new VulnerabilityScanner({
  enabled: true,
  scanInterval: process.env.NODE_ENV === 'development' ? 600000 : 300000, // 10 minutes in dev, 5 minutes in prod
  reportEndpoint: '/api/security/reports'
});

// Export type
export type SecurityThreat = VulnerabilityReport;