#!/usr/bin/env node

/**
 * Radix Bundle Size Analyzer
 *
 * Analyzes bundle sizes specifically for Radix UI dependencies
 * to prevent bloat and monitor package growth over time.
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { gzipSync, brotliCompressSync } from 'zlib';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

class RadixBundleAnalyzer {
  constructor(options = {}) {
    this.options = {
      distPath: join(__dirname, '../dist'),
      outputPath: join(__dirname, '../reports/radix-analysis'),
      thresholds: {
        totalRadixSize: 150 * 1024, // 150KB total for all Radix packages
        individualPackageLimit: 50 * 1024, // 50KB per package
        warningThreshold: 0.8, // Warn at 80% of limit
      },
      radixPackages: [
        '@radix-ui/react-avatar',
        '@radix-ui/react-checkbox',
        '@radix-ui/react-collapsible',
        '@radix-ui/react-context-menu',
        '@radix-ui/react-dialog',
        '@radix-ui/react-dropdown-menu',
        '@radix-ui/react-icons',
        '@radix-ui/react-label',
        '@radix-ui/react-navigation-menu',
        '@radix-ui/react-popover',
        '@radix-ui/react-progress',
        '@radix-ui/react-scroll-area',
        '@radix-ui/react-select',
        '@radix-ui/react-separator',
        '@radix-ui/react-slot',
        '@radix-ui/react-switch',
        '@radix-ui/react-tabs',
        '@radix-ui/react-toast',
        '@radix-ui/react-tooltip',
        '@radix-ui/react-accordion',
        '@radix-ui/react-alert-dialog',
        '@radix-ui/react-aspect-ratio',
        '@radix-ui/react-calendar',
        '@radix-ui/react-collapsible',
        '@radix-ui/react-command',
        '@radix-ui/react-context-menu',
        '@radix-ui/react-form',
        '@radix-ui/react-hover-card',
        '@radix-ui/react-menubar',
        '@radix-ui/react-navigation-menu',
        '@radix-ui/react-popover',
        '@radix-ui/react-radio-group',
        '@radix-ui/react-scroll-area',
        '@radix-ui/react-select',
        '@radix-ui/react-slider',
        '@radix-ui/react-switch',
        '@radix-ui/react-tabs',
        '@radix-ui/react-toast',
        '@radix-ui/react-toggle',
        '@radix-ui/react-toggle-group',
        '@radix-ui/react-tooltip',
        '@radix-ui/react-visually-hidden'
      ],
      ...options
    };

    this.results = {
      packages: [],
      totals: {},
      recommendations: [],
      violations: []
    };
  }

  async analyze() {
    console.log('ðŸ” Analyzing Radix UI bundle sizes...');

    try {
      console.log('ðŸ“ Ensuring output directory...');
      await this.ensureOutputDirectory();

      console.log('ðŸ“¦ Analyzing bundle composition...');
      await this.analyzeBundleComposition();

      console.log('ðŸ§® Calculating totals...');
      await this.calculateTotals();

      console.log('ðŸ“ Checking thresholds...');
      await this.checkThresholds();

      console.log('ðŸ’¡ Generating recommendations...');
      await this.generateRecommendations();

      console.log('ðŸ“„ Generating reports...');
      await this.generateReports();

      console.log('âœ… Radix bundle analysis completed successfully');
      return this.results;
    } catch (error) {
      console.error('âŒ Radix bundle analysis failed:', error.message);
      console.error('Stack:', error.stack);
      throw error;
    }
  }

  async ensureOutputDirectory() {
    if (!existsSync(this.options.outputPath)) {
      mkdirSync(this.options.outputPath, { recursive: true });
    }
  }

  async analyzeBundleComposition() {
    console.log('ðŸ“¦ Analyzing bundle composition for Radix packages...');

    const distPath = this.options.distPath;
    if (!existsSync(distPath)) {
      throw new Error(`Distribution directory not found: ${distPath}`);
    }

    // Read the bundle analysis HTML file generated by rollup-plugin-visualizer
    const bundleAnalysisPath = join(distPath, 'bundle-analysis.html');
    if (!existsSync(bundleAnalysisPath)) {
      throw new Error('Bundle analysis HTML not found. Run bundle analysis first.');
    }

    const bundleHtml = readFileSync(bundleAnalysisPath, 'utf8');

    // Extract package information from the HTML
    // This is a simplified approach - in practice, you might need to parse the actual bundle files
    await this.extractPackageSizes(bundleHtml);
  }

  async extractPackageSizes(bundleHtml) {
    // For each Radix package, try to find its size in the bundle
    // This is a simplified implementation - real implementation would analyze actual bundle chunks

    for (const packageName of this.options.radixPackages) {
      // Look for the package in the bundle HTML
      const packageRegex = new RegExp(`${packageName}[^}]*size:\\s*([0-9]+)`, 'i');
      const match = bundleHtml.match(packageRegex);

      if (match) {
        const size = parseInt(match[1]);
        const gzipSize = Math.round(size * 0.3); // Estimate gzip compression
        const brotliSize = Math.round(size * 0.25); // Estimate brotli compression

        this.results.packages.push({
          name: packageName,
          size,
          gzipSize,
          brotliSize,
          sizeFormatted: this.formatBytes(size),
          gzipSizeFormatted: this.formatBytes(gzipSize),
          brotliSizeFormatted: this.formatBytes(brotliSize),
          percentageOfTotal: 0, // Will be calculated later
        });
      } else {
        // Package not found in bundle - might be tree-shaken or not used
        this.results.packages.push({
          name: packageName,
          size: 0,
          gzipSize: 0,
          brotliSize: 0,
          sizeFormatted: '0 B',
          gzipSizeFormatted: '0 B',
          brotliSizeFormatted: '0 B',
          percentageOfTotal: 0,
          note: 'Not found in bundle (possibly tree-shaken)'
        });
      }
    }
  }

  async calculateTotals() {
    const usedPackages = this.results.packages.filter(p => p.size > 0);

    this.results.totals = {
      totalPackages: this.results.packages.length,
      usedPackages: usedPackages.length,
      unusedPackages: this.results.packages.length - usedPackages.length,
      totalSize: usedPackages.reduce((sum, p) => sum + p.size, 0),
      totalGzipSize: usedPackages.reduce((sum, p) => sum + p.gzipSize, 0),
      totalBrotliSize: usedPackages.reduce((sum, p) => sum + p.brotliSize, 0),
      averagePackageSize: usedPackages.length > 0 ?
        usedPackages.reduce((sum, p) => sum + p.size, 0) / usedPackages.length : 0,
      largestPackage: usedPackages.reduce((max, p) =>
        p.size > max.size ? p : max, { name: '', size: 0 })
    };

    // Calculate percentages
    const totalSize = this.results.totals.totalSize;
    this.results.packages.forEach(pkg => {
      pkg.percentageOfTotal = totalSize > 0 ? (pkg.size / totalSize * 100).toFixed(2) : 0;
    });
  }

  async checkThresholds() {
    console.log('ðŸ“ Checking size thresholds...');

    const { thresholds } = this.options;

    // Check total Radix size
    if (this.results.totals.totalSize > thresholds.totalRadixSize) {
      this.results.violations.push({
        type: 'total_size',
        severity: 'error',
        message: `Total Radix bundle size exceeds limit: ${this.formatBytes(this.results.totals.totalSize)} > ${this.formatBytes(thresholds.totalRadixSize)}`,
        recommendation: 'Consider removing unused Radix components or implementing lazy loading'
      });
    } else if (this.results.totals.totalSize > thresholds.totalRadixSize * thresholds.warningThreshold) {
      this.results.violations.push({
        type: 'total_size',
        severity: 'warning',
        message: `Total Radix bundle size approaching limit: ${this.formatBytes(this.results.totals.totalSize)} / ${this.formatBytes(thresholds.totalRadixSize)}`,
        recommendation: 'Monitor Radix package usage and consider optimization'
      });
    }

    // Check individual package sizes
    this.results.packages.forEach(pkg => {
      if (pkg.size > thresholds.individualPackageLimit) {
        this.results.violations.push({
          type: 'individual_package',
          severity: 'warning',
          package: pkg.name,
          message: `Package ${pkg.name} exceeds individual limit: ${pkg.sizeFormatted} > ${this.formatBytes(thresholds.individualPackageLimit)}`,
          recommendation: 'Consider if all features from this package are needed'
        });
      }
    });
  }

  async generateRecommendations() {
    console.log('ðŸ’¡ Generating optimization recommendations...');

    const recommendations = [];

    // Unused packages
    const unusedPackages = this.results.packages.filter(p => p.size === 0 && !p.note);
    if (unusedPackages.length > 0) {
      recommendations.push({
        type: 'optimization',
        priority: 'high',
        title: 'Remove unused Radix packages',
        description: `${unusedPackages.length} Radix packages appear unused and can be removed`,
        packages: unusedPackages.map(p => p.name),
        impact: 'Reduce bundle size by removing dead code'
      });
    }

    // Large packages
    const largePackages = this.results.packages
      .filter(p => p.size > 30 * 1024) // > 30KB
      .sort((a, b) => b.size - a.size);

    if (largePackages.length > 0) {
      recommendations.push({
        type: 'optimization',
        priority: 'medium',
        title: 'Optimize large Radix packages',
        description: `Consider lazy loading or selective imports for large packages`,
        packages: largePackages.slice(0, 3).map(p => `${p.name} (${p.sizeFormatted})`),
        impact: 'Reduce initial bundle size with code splitting'
      });
    }

    // Tree shaking effectiveness
    const treeShakingRatio = this.results.totals.usedPackages / this.results.totals.totalPackages;
    if (treeShakingRatio < 0.7) {
      recommendations.push({
        type: 'optimization',
        priority: 'medium',
        title: 'Improve tree shaking',
        description: `Only ${Math.round(treeShakingRatio * 100)}% of Radix packages are used. Ensure proper imports.`,
        impact: 'Reduce bundle size by eliminating unused code'
      });
    }

    this.results.recommendations = recommendations;
  }

  async generateReports() {
    console.log('ðŸ“„ Generating analysis reports...');

    // JSON report
    const jsonReport = {
      timestamp: new Date().toISOString(),
      summary: {
        totalPackages: this.results.totals.totalPackages,
        usedPackages: this.results.totals.usedPackages,
        totalSize: this.formatBytes(this.results.totals.totalSize),
        totalGzipSize: this.formatBytes(this.results.totals.totalGzipSize),
        compressionRatio: this.results.totals.totalSize > 0 ?
          ((1 - this.results.totals.totalGzipSize / this.results.totals.totalSize) * 100).toFixed(1) + '%' : '0%'
      },
      packages: this.results.packages,
      violations: this.results.violations,
      recommendations: this.results.recommendations
    };

    writeFileSync(
      join(this.options.outputPath, 'radix-bundle-analysis.json'),
      JSON.stringify(jsonReport, null, 2)
    );

    // Markdown report
    const markdownReport = this.generateMarkdownReport();
    writeFileSync(
      join(this.options.outputPath, 'radix-bundle-analysis.md'),
      markdownReport
    );

    console.log(`ðŸ“Š Reports saved to: ${this.options.outputPath}`);
  }

  generateMarkdownReport() {
    const { totals, packages, violations, recommendations } = this.results;

    return `# Radix UI Bundle Analysis Report

Generated: ${new Date().toISOString()}

## Summary

- **Total Radix Packages**: ${totals.totalPackages}
- **Used Packages**: ${totals.usedPackages}
- **Unused Packages**: ${totals.unusedPackages}
- **Total Size**: ${this.formatBytes(totals.totalSize)}
- **Gzipped Size**: ${this.formatBytes(totals.totalGzipSize)}
- **Average Package Size**: ${this.formatBytes(Math.round(totals.averagePackageSize))}
- **Largest Package**: ${totals.largestPackage.name} (${this.formatBytes(totals.largestPackage.size)})

## Package Breakdown

| Package | Size | Gzipped | % of Total | Status |
|---------|------|---------|-----------|--------|
${packages.map(pkg =>
  `| ${pkg.name} | ${pkg.sizeFormatted} | ${pkg.gzipSizeFormatted} | ${pkg.percentageOfTotal}% | ${pkg.note || 'Used'} |`
).join('\n')}

## Issues

${violations.length === 0 ? 'âœ… No threshold violations detected' :
  violations.map(v => `### ${v.severity.toUpperCase()}: ${v.message}\n${v.recommendation}\n`).join('\n')
}

## Recommendations

${recommendations.length === 0 ? 'No recommendations - bundle is well optimized! ðŸŽ‰' :
  recommendations.map(r =>
    `### ${r.priority.toUpperCase()}: ${r.title}\n${r.description}\n**Impact**: ${r.impact}\n${
      r.packages ? `**Affected packages**: ${r.packages.join(', ')}\n` : ''
    }`
  ).join('\n')
}

## Thresholds

- Total Radix Size Limit: ${this.formatBytes(this.options.thresholds.totalRadixSize)}
- Individual Package Limit: ${this.formatBytes(this.options.thresholds.individualPackageLimit)}
- Warning Threshold: ${(this.options.thresholds.warningThreshold * 100).toFixed(0)}%

---
*This report helps monitor Radix UI bundle bloat and provides actionable recommendations for optimization.*
`;
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }
}

// CLI interface
console.log('ðŸš€ Starting Radix Bundle Analyzer...');
const analyzer = new RadixBundleAnalyzer();

analyzer.analyze()
  .then(results => {
    console.log('\nðŸ“Š Radix Bundle Analysis Summary:');
    console.log(`Total Size: ${analyzer.formatBytes(results.totals.totalSize)}`);
    console.log(`Used Packages: ${results.totals.usedPackages}/${results.totals.totalPackages}`);
    console.log(`Violations: ${results.violations.length}`);

    if (results.violations.some(v => v.severity === 'error')) {
      console.log('\nâŒ Critical violations found - check the report for details');
      process.exit(1);
    } else if (results.violations.length > 0) {
      console.log('\nâš ï¸  Warnings detected - review recommendations');
      process.exit(0);
    } else {
      console.log('\nâœ… All Radix bundle checks passed!');
      process.exit(0);
    }
  })
  .catch(error => {
    console.error('Analysis failed:', error);
    process.exit(1);
  });

export default RadixBundleAnalyzer;