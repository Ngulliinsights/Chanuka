# Validation Schema to Database Alignment Guide

**Date**: 2026-02-13  
**Status**: Implemented  
**Related**: `.kiro/specs/full-stack-integration/CONSTRAINT_VALIDATION_AUDIT.md`

## Overview

This document explains the alignment between Zod validation schemas and database constraints. Following the audit in Task 7.4, validation schemas have been updated to match database schema definitions.

## Key Principles

1. **Database as Source of Truth**: Database constraints (NOT NULL, CHECK, UNIQUE) define the authoritative requirements
2. **Validation Matches Database**: Validation schemas enforce the same constraints as the database
3. **Field Names Match**: Validation schema field names match database column names exactly
4. **Legacy Support**: Old schemas are preserved with `Legacy` prefix for backward compatibility

## Schema Alignments

### 1. User Schemas

#### Changes Made

**Before**: Single `UserSchema` combined fields from both `users` and `user_profiles` tables

**After**: Separated into three schemas:
- `UserSchema`: Maps to `users` table only
- `UserProfileSchema`: Maps to `user_profiles` table only  
- `UserWithProfileSchema`: Combined schema for convenience

#### Field Mappings

| Validation Field | Database Table | Database Column | Notes |
|-----------------|----------------|-----------------|-------|
| id | users | id | UUID, generated by DB |
| email | users | email | NOT NULL, UNIQUE |
| username | users | username | NOT NULL, UNIQUE |
| role | users | role | NOT NULL, enum, default 'citizen' |
| is_active | users | is_active | NOT NULL, default true |
| first_name | user_profiles | first_name | varchar(100), NULL allowed |
| last_name | user_profiles | last_name | varchar(100), NULL allowed |
| display_name | user_profiles | display_name | varchar(150), NULL allowed |
| bio | user_profiles | bio | text, NULL allowed, validation limits to 500 chars |
| phone_number | user_profiles | phone_number | varchar(20), NULL allowed |
| is_public | user_profiles | is_public | NOT NULL, default true |

#### Length Constraint Updates

- `first_name`: Updated from max 50 to max 100 (matches DB varchar(100))
- `last_name`: Updated from max 50 to max 100 (matches DB varchar(100))
- `phone`: Renamed to `phone_number` and limited to max 20 (matches DB varchar(20))

#### Usage

```typescript
// For users table operations
import { UserSchema } from '@shared/validation/schemas/user.schema';

// For user_profiles table operations
import { UserProfileSchema } from '@shared/validation/schemas/user.schema';

// For combined user + profile forms
import { UserWithProfileSchema } from '@shared/validation/schemas/user.schema';
```

### 2. Comment Schema

#### Changes Made

**Before**: Used field names `content`, `author_id`, made `bill_id` optional

**After**: Aligned with database column names and constraints

#### Field Mappings

| Validation Field | Database Column | Change | Reason |
|-----------------|-----------------|--------|--------|
| comment_text | comment_text | Renamed from `content` | Match DB column name |
| user_id | user_id | Renamed from `author_id` | Match DB column name |
| bill_id | bill_id | Made required | DB has NOT NULL constraint |
| parent_comment_id | parent_comment_id | Renamed from `parent_id` | Match DB column name |

#### Removed Fields

- `argument_id`: Not in database schema
- `is_edited`: Not in database schema (can be derived from updated_at)

#### Length Constraints

- `comment_text`: Max 5000 characters (validation constraint, DB has no limit)

#### Usage

```typescript
// New aligned schema
import { CommentSchema } from '@shared/validation/schemas/comment.schema';

// Legacy schema (for backward compatibility)
import { LegacyCommentSchema } from '@shared/validation/schemas/comment.schema';
```

### 3. Bill Schema

#### Changes Made

**Before**: Used field name `content`, made `bill_number` and `chamber` optional, included `type` and `priority` fields

**After**: Aligned with database column names and constraints

#### Field Mappings

| Validation Field | Database Column | Change | Reason |
|-----------------|-----------------|--------|--------|
| title | title | Max length 500 | DB allows varchar(500) |
| summary | summary | Made optional | DB allows NULL |
| full_text | full_text | Renamed from `content`, made optional | Match DB column name, DB allows NULL |
| bill_number | bill_number | Made required | DB has NOT NULL constraint |
| chamber | chamber | Made required | DB has NOT NULL constraint |
| status | status | Updated enum values | Match DB enum definition |

#### Removed Fields

- `type`: Not in database schema
- `priority`: Not in database schema

#### Status Enum Alignment

**Database Enum Values**:
```typescript
['draft', 'first_reading', 'second_reading', 'committee', 
 'third_reading', 'passed', 'rejected', 'assented', 'enacted']
```

**Default**: `'first_reading'` (matches DB default)

#### Chamber Enum Alignment

**Database Enum Values**:
```typescript
['national_assembly', 'senate', 'joint']
```

#### Usage

```typescript
// New aligned schema
import { BillSchema } from '@shared/validation/schemas/bill.schema';

// Legacy schema (for backward compatibility)
import { LegacyBillSchema } from '@shared/validation/schemas/bill.schema';
```

## Migration Guide

### For Existing Code Using Old Schemas

#### Option 1: Update to New Schemas (Recommended)

```typescript
// Before
const comment = {
  content: "This is a comment",
  author_id: userId,
  bill_id: billId,
};

// After
const comment = {
  comment_text: "This is a comment",
  user_id: userId,
  bill_id: billId,
};
```

#### Option 2: Use Legacy Schemas (Temporary)

```typescript
// Use legacy schema for backward compatibility
import { LegacyCommentSchema } from '@shared/validation/schemas/comment.schema';

// Then transform to DB format before saving
const dbComment = {
  comment_text: legacyComment.content,
  user_id: legacyComment.author_id,
  bill_id: legacyComment.bill_id,
};
```

### For New Code

Always use the aligned schemas:
- `UserSchema` and `UserProfileSchema` for user data
- `CommentSchema` for comments
- `BillSchema` for bills

## Intentional Differences

Some differences between validation and database are intentional:

### 1. Length Constraints on Text Fields

**Validation**: Enforces maximum lengths (e.g., bio: 500 chars, comment_text: 5000 chars)  
**Database**: Uses `text` type with no length limit

**Reason**: Validation provides user-friendly limits while database allows flexibility for future changes

### 2. Internal Metrics Fields

Fields like `failed_login_attempts`, `completeness_score`, `profile_views` are in the database but not in validation schemas.

**Reason**: These are internal system fields not exposed to users

### 3. Generated Fields

Fields like `id`, `created_at`, `updated_at` are optional in validation but NOT NULL in database.

**Reason**: These are generated by the database, not provided by users

## Testing Alignment

Property-based tests verify alignment:

```typescript
// tests/properties/validation-at-integration-points.property.test.ts
// Validates that validation schemas match database constraints
```

## Future Considerations

### When Adding New Fields

1. Add to database schema first
2. Update validation schema to match
3. Update this documentation
4. Run alignment tests

### When Modifying Constraints

1. Update database constraint
2. Update validation rule
3. Update this documentation
4. Verify no breaking changes

## Related Documentation

- Database Schema: `server/infrastructure/schema/`
- Validation Schemas: `shared/validation/schemas/`
- Audit Report: `.kiro/specs/full-stack-integration/CONSTRAINT_VALIDATION_AUDIT.md`
- Requirements: `.kiro/specs/full-stack-integration/requirements.md` (Requirement 5.4)
